#### 一、头文件

##### 1、使用include guard

避免重复包含

##### 2、避免使用前置声明，尽可能使用#include

函数总是使用#include

类模板优先使用#include

前置声明的类是不完整类型，只能用来定义类的指针或引用，或者声明（只能声明，不能定义）以不完整类型作为参数或者返回类型的函数。因为编译器不知道不完整类型的定义，故不能创建此类的对象，也不能声明此类的内部数据成员。

##### 3、只有当函数只有10行或者更少时，定义为内联函数 inline

谨慎对待析构函数，因为析构函数往往比其看起来更多，它会隐式的调用基类析构函数和隐含的成员

内联函数中尽量不要使用循环或者switch语句

递归函数不应该被声明为内联函数

##### 4、#include中避免使用`. ` `..`等快捷目录，使用项目代码的目录树排布

##### 5、#include时，在.cpp中，其对应的.h应该在最前面

这样出错可以马上感知，而不是怀疑其他的包出错；除此外，头文件的包含顺序可以为 “ C 系统文件 - C ++ 系统文件 - 其他库.h文件 - 本项目内的.h文件 ”，不过有些需要条件编译的include可以放到最后`#ifdef LINUX #include <xxx.h> #endif`；同级别内使用字母排序，观感也不错

##### 6、避免隐藏依赖

所依赖的symbols定义在哪些头文件中，那就包含那些头文件；如需要用到bar.h中定义的symbol，那么即使已经包含的foo.h中已经包含了bar.h，也照样包含bar.h，除非foo.h中明确说明了会自动提供bar.h中的symbol



#### 二、作用域

##### 1、命名空间

.cpp中鼓励使用匿名命名空间，但不要在.h中使用匿名命名空间，违背了C++的唯一定义原则；

不要使用内联命名空间，和using-directive（using 指示），using指示（不是using-declaration using声明）会污染命名空间；

函数、方法、类中可以使用命名空间别名；

不要在std命名空间中声明任何东西，包含标准库的前置声明，因为在std中声明实体会导致不确定的问题；

##### 2、嵌套类（成员类）

不要把嵌套类定义为public，除非它是接口的一部分

##### 3、全局函数

使用static成员函数或者命名空间中的非成员函数，而不是定义在全局命名空间中，作为裸的全局函数

##### 4、局部变量

作用域尽可能小，并且变量使用声明时进行初始化，而不是声明再复赋值；

变量声明并初始化时离第一次使用尽可能的近，方便代码浏览者定位声明位置；

##### 5、静态和全局变量

禁止使用class类型的静态或全局变量，因为其构造函数、析构函数和初始化顺序在C++中不确定，导致难以发现的bug（如在不同的编译单元中调用）。

> 单例的实现中必须使用class类型的静态变量，所以Effective C++中将non-local的static class变量转换为了函数内的local static 变量，从而避免了此问题出现 p61



#### 三、类

##### 1、构造函数的职责

构造函数中不要进行复杂的初始化，如果有可能异常的初始化行为，使用明确的`Init()`函数或者工厂模式

> 工厂模式？怎么用在构造中

构造函数中不要使用自身的虚函数，因为此时虚函数是不会被重定向到子类中的，如基类的构造函数中会认为所有的虚函数均为基类中的实现

##### 2、初始化

简单的类成员初始化可以在声明时完成，尤其是在该成员变量会在多个构造函数中以相同的方式初始化，如`int count_ = 17; `用来替换`int count_;`

如果成员变量既没有在类中声明时初始化，又没有提供构造函数，那么必须定义一个默认构造函数，把内部状态初始化成合理的方式；因为编译器生成的默认构造函数不会对成员做合理初始化



##### 3、显式构造函数

对单个参数的构造函数使用`explicit`标识，防止隐式转化（避免不合时宜的转化）；

此规则同样适用于除第一个参数外，其他参数都具有默认参数的构造函数



只有 std::initializer_list 的构造函数可以是非 explicit, 以允许你的类型结构可以使用列表初始化的方式进行赋值

```C++
MyType m = {1, 2};

MyType MakeMyType()
{
  return {1, 2};
}
```

##### 4、可拷贝类型和可移动类型（拷贝构造，拷贝赋值运算符，移动构造，移动赋值运算符）

将类class是否支持拷贝或者移动明确化，如果支持拷贝或移动，就给出定义（哪怕是 = default），而不是编译器隐式生成；同样如果不使用拷贝或移动，就把编译器隐式生成的拷贝和移动构造函数禁用（= delete）。

>可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值，或在赋值时被赋予相同类型的另一对象的值
>
>可移动类型代表允许对象在初始化时得到来自相同类型的**临时对象**的值，或在赋值时被赋予相同类型的**临时对象**的值（因此可拷贝对象也是可移动的）

拷贝和移动会在某些情况下被隐式调用，如传值的方式传递对象，函数内返回对象时；

不要给基类提供拷贝属性！会造成所谓“对象切割”，如某函数参数为基类对象，而传入一个派生类对象，此时会隐式调用基类的拷贝构造，也就意味着派生类部分全部被丢弃了

如果一定要给基类提供拷贝属性，那么就提供一个`public virtual Clone()`和一个`protected` 的拷贝构造函数以供派生类使用。

##### 5、委派和继承构造函数

C11引入的机制，委派即允许类的构造函数可以调用其他构造函数；

继承即允许派生类直接调用基类的构造函数，无需重新声明，使用如下

```C++
class Base
{
  public:
  	Base();
  	Base(int n);
  	...
};

class Derived : public Base
{
  public:
  	using Base::Base;//说明使用Base类的构造函数
  	//但是如果子类中有基类不存在的新的成员变量，不太适合；
  	//但如果新的成员变量在子类中声明时即初始化则可以正常使用

};
```



##### 6、结构体 vs. 类

当只有数据时使用`struct`，只能提供构造、析构函数、Initalize()、Reset()、Validate()等类似函数

其他全部使用`class`

##### 7、继承

 C++ 实践中, 继承主要用于两种场合: 实现继承 (implementation inheritance)，即子类继承父类的实现代码；接口继承 (interface inheritance)，即子类仅继承父类的方法名称。

所有继承必须是`public`，如果要使用私有继承，替换为把基类的实例作为成员对象的方式。

**使用组合Compostion比使用继承更合理**，尽量做到只使用“is a”，所有的“has a”使用组合方式。

必要时，析构函数声明为virtual，如果类中有虚函数，那么析构也应该为虚函数，因为可能用一个基类指针指向一个子类对象，如果析构不是`virtual`，那么此时析构基类指针会导致部分销毁问题，即子类部分未被释放；

重载虚函数时，在子类中明确的声明为virtual，防止代码阅读者不得不检查所有父类，才能判断出该函数是否是虚函数。

优先级： 组合 > 实现继承 > 接口继承 > 私有继承

##### 8、多重继承

尽量不要使用多重继承，只有当所有父类除第一个外都是纯接口类，才允许使用多重继承。（最多一个基类是非抽象类）

##### 9、接口

建议此种类以Interface为后缀

当类满足以下要求时，称之为纯接口：

1）**只有纯虚函数**（=0）和静态函数（除析构）

2）没有非静态数据成员

3）没有定义任何构造函数，如果有，也不能带有参数，且必须为`protected`

4）如果它是一个子类，也只能从满足上述条件并以Interface为后缀的类继承

接口类不能被直接实例化，因为它声明了纯虚函数（抽象类），但为了保证接口类的所有实现都可以被正确销毁，必须为之声明虚析构函数，因为可能使用一个基类指针指向一个派生类对象，此时如果析构不是virtual，就无法调用正确的子类析构函数，那么析构就不彻底，其子类部分未被销毁！



##### 10、重载运算符

非特殊情况，不要重载运算符；如果有必要，定义类似`Equal(); CopyFrom()`等函数

不要为了在STL容器中用作键值就重载`operator <` 、`operator ==`，此种情况更建议在定义容器时就创建用于相等判断和大小比较的仿函数



##### 11、存取控制

将**所有**数据成员声明为 `private`, 并根据需要提供相应的存取函数；存取函数一般在.h文件中定义为内联函数



##### 12、声明顺序

先public、再private，friend最后，且函数声明在数据成员之前

.cpp中的定义顺序最好和声明顺序保持一致



##### 13、编写简短函数

如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割



#### 五、来自Google的奇技

##### 1、所有权和智能指针

RAII思想：资源获取的时机便是初始化时机，所有权即以对象来管理资源，当离开作用域时自动的调用析构函数，完成资源释放；最常用的有`shared_ptr`和`unique_ptr`：`shared_ptr`表示动态分配对象的所有权，并且此所有权可以复制，可被共享，复制后所有权归所有复制者共同所有，当最后一个复制者被销毁时，对象也随之销毁；而`unique_ptr`表示动态分配的对象的独一无二的所有权，即此所有权不可以被复制，当`unique_ptr`离开作用域，对象即被销毁，但是此所有权可以被移动（move）给新的所有者。

在代码中用`unique_ptr`去代替以往的`auto_ptr`，`auto_ptr`也表示独一无二的所有权，但是它的所有权是可以复制的，一旦发生复制，那么新的所有者将拥有此独一无二的所有权，旧所有者将失去所有权，所有权不能共享。

>对智能指针的理解：
>
>其实可以把`shared_ptr`  `unique_ptr`视作对象，就像同样常见的RAII类`MutexHelper`管理着mutex互斥量一样，只不过区别在于智能指针管理着指针这一资源，而且使用模板`template`使之可以管理几乎所有的指针类；同时智能指针对于复制行为的定义也不同，如`shared_ptr`对于复制的行为是：底层使用引用计数器，使得所有的复制者均指向同一个内存区域，而计数器为0时代表清空；`MutexHelper`更多的是禁止复制行为，毕竟复制一个互斥器，几乎是没有意义的。
>
>恰如GSG所言，"把智能指针当成一个重载了 * 和 -> 的「**对象**」来看；"



#### 六、其他C++特性

##### 1、引用参数

**所有的引用参数必须是`const`**

同时输入参数必须为值参或者引用，输出参数必须为指针

`void Foo(const A& in, string* out);`

##### 2、右值引用

只在定义移动构造函数和移动赋值语句时使用右值引用，不要使用`std::forward`

##### 3、函数重载

合理使用函数重载，最好让使用者一看调用点就知道使用的是哪个重载函数；

如果可以不要一股脑的使用函数重载，可以试试在函数名上加上参数名称，如AppendInt、AppendString，而不是全部重载为Append()，然后只有参数类型不同，让人分不清最终调用的是哪种。

##### 4、缺省参数

我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载

因为缺省参数会修改函数签名（function signature），如void func() 和 void func(int a = 0)两者的函数签名不同；**当把缺省函数作为指针时（函数指针），会丢失缺省参数信息**。



所以除了以下情况，我们要求必须显式提供所有参数：

1）位于 .cc 文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。

2）可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。

3）可以用来模拟变长数组（即最后的参数使用缺省，从而假装只有少数参数）

##### 5、变长数组和alloca()

不允许使用变长数组和`alloca()`

改用更安全的分配器，如`std::vector` 或者 `std::unique_ptr<T[]>`（后者完全没用过。。。）



##### 6、友元

合理使用友元类和友元函数

通常将友元（类或函数）定义在同一个文件中，防止代码阅读者还需要跑到另一个文件中才能看到使用该私有成员的类。



##### 7、异常

不使用C++异常，但仅仅是出于Google自身的软件管理成本而言，毕竟他有着大量的未使用异常的C++旧代码，贸然使用异常，尤其当允许异常向外扩散时，新旧代码整合将更加困难

异常会使得二进制文件大小增长百分之十到百分之二十，不过一般项目对于二进制文件大小没什么太多要求，所以除非有严苛的实时性和空间类要求，异常还是建议使用！



**Q：当构造失败时，只有异常可以处理？？？**



##### 8、运行时类型识别`RTTI`

**禁用RTTI**，单元测试中可以使用RTTI，用来判断所生成的对象是否为期望的动态类型

RTTI：running time type identification，允许程序员可以在运行时识别C++类对象的类型，通常通过使用`typeid`和`dynamic_cast`完成

RTTI替代方案：

1）虚函数可以根据不同的子类类型执行不同的代码（虚函数本身就是RTTI的），这就把判断类型的工作交给对象本身去完成；

2）如果”根据不同对象类型执行不同行为“，需要在对象之外完成的，考虑使用双重分发的方案？？如访问者设计模式，从而在对象外实现类型判断；

3）如果能够确定给定的基类对象实际是某个派生类的对象，那就可以自由的使用`dynamic_cast`

不要使用基于类型的判断树，如下，如果在类层级中加入新的子类，下列代码往往会崩溃

```C++
//禁用！！！！
if (typeid(*data) == typeid(D1))
{
  ...
}
else if (typeid(*data) == typeid(D2))
{
  ...
}
else if (typeid(*data) == typeid(D3))
{
  ...
}
```



##### 9、类型转换

使用C++的类型转换，如`static_cast<>`，不要使用`int y = (int)x`或者`int y = int(x)`等方式！！

`static_cast<>`代替C风格的值转换，或某个类指针明确的向上转换为父类指针；

`const_cast<>`去掉const限定；

`reinterpret_cast<>`用于指针类型 和 整型或其他指针类型 之间进行不安全的相互转换。



##### 10、流

除了日志，都不要使用流cout；而是printf  + read\write



##### 11、前置自增和自减

对迭代器或者模板对象时，使用前置自增，因为后置自增会有一次额外的拷贝操作，而迭代器中通常不需要此拷贝。（不过，据说在编译器优化下，迭代器等场景中前置后置几乎性能无区别）



##### 12、const用法

**建议在任何可能的情况下，都使用const，不论是变量 or 成员函数**

初始化const对象时，必须在初始化时同时做值初始化，否则之后就没有机会赋值了；

`mutable`可以使用，但是**多线程下不安全**

##### 13、constexpr用法

C11中，变量被声明为constexpr以表明它是真正意义上的常量，**即编译和运行期间均不会变**。

Q：那么const声明的常量呢？为什么不是真正意义上的常量



##### 14、整型

通常意义上，理解short为16位，int为32位，long为32位，long long为64位，但实际上却决于使用的编译器和计算机体系结构。

通常使用int即可，需要时使用`<stdint.h>`下的int16_t、int_32_t等

不要使用无符号整型，因为整型提升等问题，可能导致bug，比如我自己遇到的，总之对待无符号类型需要谨慎；**针对那些需要确保非负的值，使用断言，而不是无符号整数类型**

```C++
//因为size_t 是无符号类型，所以此循环永远不会结束！！i==0时，再-1，二进制下会全1，所以永远大于0
for (size_t i = s.Length() - 1; i >= 0; --i)...
```



##### 15、64位下的可移植性

小心使用结构体对齐，尤其是要持久化到磁盘上的结构体（持久化--即将数据按照字节流顺序保存在磁盘文件或者数据库中）。如果32位和64位系统需要共有持久化的结构体，需要确保两种体系下的结构体对齐一致，如gcc中使用`__attribute__((packed))`，MSVC中使用`#pragma pack()`或`__declspec(align())`

创建64位常量时使用LL或者ULL作为后缀，如`int64_t my_value = 0x123456789LL;` `uint64_t my_mask = 3ULL << 48;`



##### 16、预处理宏

少用为妙，因为使用宏，使得看到的代码和编译器看到的代码不同

宏展开的代码，使用内联代替；

宏常量 ，使用const常量；

宏”缩短“长变量名，使用引用代替；

宏条件编译，少用！



##### 17、0，nullptr，NULL

整数用0，实数用0.0；

指针用nullptr（C11）或NULL；

字符（串）用' \0'



##### 18、sizeof

尽可能使用sizeof(varname)，而不是sizeof(type)；因为代码中变量类型变动时会自动更新，如`memset(&data, 0, sizeof(data))`，而不是`memset(&data, 0, sizeof(Struct))`

不过如果不涉及变量代码，可用sizeof(type)处理来自内部或外部的数据格式。

> **新鲜经验：**
>
> sizeof(data)是没错，但是！！如果有个指针变量，而你要的sizeof是指针指向的资源大小，千万不要脑残的随手就sizeof(ptr)，指针永远都那么大。。。。

##### 19、auto

auto最好只用在局部变量中，而且要确保使用auto后，仍然可以看出类型



##### 20、列表初始化

C++03中即支持对聚合类型的列表初始化，如数组和不带构造函数的struct

```C++
int a[] {1,2,3};
struct Point
{
  int x;
  int y;
};

Point p = {1, 2};
```

C++11中，支持对所有对象类型的列表初始化：

用户自定义类型通过定义接收`std::initializer_list<T>`的构造函数和赋值运算符，也可以列表初始化

```C++
#include <vector>
class MyType
{
private:
    std::vector<int> vec_;
public:
    MyType() = default;
    
    MyType(std::initializer_list<int> init_list)
    {
        // vec_ = {init_list};
        for (int i : init_list)
            vec_.push_back(i);
    }
    ~MyType();

    MyType& operator=(std::initializer_list<int> init_list)
    {
        vec_.clear();
        for (int i : init_list)
            vec_.push_back(i);
    }
};
```



```C++
std::vector<int> vec{1,2,3};
vec = {1,2,3, 4, 5};
//和new搭配使用
auto p = new std::vector<int>{1, 2, 3, 4};
//隐式转换
vector<int> func() {return {1, 2, 3};}
map<int, string> m = {{1, "one"}, {2, "two"}};
```



内置类型也可以使用列表初始化，即使没有接收`std::initializer_list<T>`的构造函数

`double d{1.23};`



auto和列表初始化不要乱混用，可能导致根本看不出是什么类型

`auto x{2};//x是initializer_list<int>类型`

`auto y(3);//y是int类型`



##### 21、lambda表达式

lambda表达式是创建匿名函数对象的途径之一，常用于把函数作为参数传，如：

```C++
std::sort(v.begin(), v.end(), [](int x, int y){
  Weight(x) < Weight(y);
});
```



禁用默认lambda捕获，捕获最好显式的写出来，如比起`[=](int x){return x + n;}`写成`[n](int x){return x+n;}`，这样一眼就可以看出捕获的是n

匿名函数要简短，如果函数体超出5行，还不如把lambda改为函数或者赋值给对象



##### 22、模板编程

不要使用复杂的模板编程



#### 七、命名约定

##### 1、通用准则

**命名要有描述性，少用缩写**，不要心疼空间，代码以理解为目的

##### 2、文件命名

全部小写，可以使用下划线`_`或者连字符`-`，下划线最好

`fast_election.h   fast_election.cpp`

##### 3、类命名

单词首字母大写，不用下划线

`class UrlTable {};`

##### 4、变量命名

变量名全部小写，单词间用下划线连接，类成员变量用下划线结尾，但结构体`struct`的成员不用

普通变量（及结构体成员变量）：全小写 + 下划线分割 `string table_name;`

类成员变量：全小写 + 下划线分割 + 下划线结尾 `string table_name_;`

全局变量：少用为好，`g_`作为前缀，`string g_table_name;`

##### 5、常量命名

以k为开头，然后单词首字母大写

`const int kDaysInAWeek = 7;`

##### 6、函数命名

一般函数：单词首字母大写，没有下划线；（如果某函数出错时会直接crash，在函数名加上OrDie）

取值和设值函数：采取和要存取的变量名匹配原则，小写（如设置类成员 `num_entries_`，存取函数名为：`num_entries()`、`set_num_entries()`）

##### 7、命名空间命名

小写字母，基于项目名称和目录结构

##### 8、枚举命名

采取和常量相同的方式

```C++
enum UrlErrors
{
  kOk = 1,
  kErrorOutOfMemory,
};
```



##### 9、宏命名

全部大写，使用下划线；尽量不要使用宏！！

##### 10、特例

如果命名的实体和已有的C/C++实体相似，可参考已有的命名策略

```C++
bigopen(); //参考open()
LONGLONG_MAX//参考INT_MAX
sparse_hash_map//参考STL中hash_map
```



#### 八、注释

**注释固然很重要, 但最好的代码本身应该是自文档化. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊**
**不清的名字.**

##### 1、注释风格

使用// 或者 /* */，统一就可以

##### 2、文件注释

##### 3、类注释

每个类的定义都要附带一份注释，描述类的功能和用法

尤其是那些有同步前提，或者类的实例会被多线程访问，要说明对应环境下的使用

##### 4、函数注释

**函数声明**处注释描述函数**功能**；**函数定义**处描述函数**实现**

###### 声明处内容：

函数的输入输出、如果函数分配了空间，需要调用者释放、参数是否可以为NULL、是否存在函数使用上的性能隐患、是否可重入、针对类成员函数，函数调用期间对象是否需要保持引用参数，是否释放这些参数

注释构造/析构函数时, 切记读代码的人知道构造/析构函数是干啥的, 所以 “destroys this object” 这样的
注释是没有意义的. 注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么.
如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的



###### 定义处内容：

简要说明功能，并说明函数实现要点，如编程技巧，实现步骤，或着解释如此实现的理由，为什么前半部分加锁而后半部分不用



##### 5、变量注释

变量名本身就能说明用途，某些情况下，额外注释说明

如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明

##### 6、实现注释

对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.

**巧妙或复杂的代码段前要加注释.** 

**比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释**

**向函数传入 NULL, 布尔值或整数时, 要注释说明含义, 或使用常量让代码望文知意**

```C++
bool success = CalculateSomething(interesting_value,
							    10, // Default base value.
							    false, // Not the first time we're calling this.
							    NULL); // No callback.
```

##### 7、TODO注释

对那些临时的、短期的解决方案，或已经够好但是不完美的代码使用TODO注释；标记一些未完成或者完成的不够好的地方

`//TODO(zyc) change this to use relations.`

##### 8、弃用注释

使用`DEPRECATED`标记某接口点已经弃用

