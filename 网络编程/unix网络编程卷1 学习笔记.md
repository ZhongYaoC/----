#### 第一章

* 针对iPV4、iPV6环境，建议程序能够独立于网络协议，即程序可同时处理V4和V6的数据包；
* 为防止安全问题和意外错误，建议使用以下函数

| 建议              | 被替换     | 原因                                       |
| --------------- | ------- | ---------------------------------------- |
| bzero           | memset  | bzero两参数，更好记忆                            |
| snprintf        | sprintf | 后者可能出现缓冲区溢出现象（如大量同时调用该函数），前者第二参数会指定缓冲区大小 |
| fgets           | gets    | ？                                        |
| strncat/strlcat | strcat  |                                          |
| strncpy/strlcpy | strcpy  |                                          |
|                 |         |                                          |

* TCP是一个没有记录边界的字节流，本身不提供记录结束标志，所以需要应用程序自己实现，如实际数据流前加上记录长度或者每条记录后人为加上结束符号。

* 包裹函数：因为一般发生错误时，采取终止程序运行的方式，所以通过包裹函数缩短程序。内部包括实际的函数调用，检查返回值，发生错误时终止进程。一般情况下，包裹函数名为实际调用函数名的首字母大写形式。

* 函数（如某个套接字函数）发生错误时，将**全局变量errno**置为指明该错误类型的正值，函数本身返回-1。errno只在函数发生错误时定义，没有错误时即没有定义，值为0不代表错误。不过全局变量方式不适用于多线程（会共享全局变量）程序中。



* 服务器程序需要考虑多并发处理，可以使用多进程fork，或者多线程，亦或是线程池方式。



* 守护daemon进程：运行在后台而不与任何终端关联的进程



* 网络应用绕开传输层，直接使用iPV4、iPV6（原始套接字）；甚至绕开传输、网络层，直接读写数据链路层的帧（怎么做的，为什么要绕开？减少拆包并包开销？直接炸开TCP/IP架构？优缺点，使用场景？）



##### 本章小结

习题有感：

接触一个全新的东西，最最权威的、最正确的只有官方文档（含官方README），每次都有这种感慨，每次都犯老毛病；

strlen(const char *)和sizeof()完全两码事，strlen求字符串长度，遇到‘’\0’停止，长度本身不含‘\0’，只接受指针参数；sizeof求实参所占的地址空间大小，如果是字符串，会把结尾的’\0’所占地址算上；

linux 命令和makefile该复习（or 重新学习）。



#### 第二章

SCTP非重点，重点还是在TCP/IP；

SCTP之多宿性：使单个SCTP端点能够支持多个IP地址，从而提高网络故障时的鲁棒性。一个端点有多个冗余的网络连接，每个网络可能基于不同的网络基础设施（如数据中心中完全独立的两套核心交换机、路由器）。当该端点与另一端点建立关联后，如果出现网络故障，可以切换到使用已与该关联相关的另一地址，来规避故障。P31

> 感觉是单主机分配不同ip，每套ip底层基于不同基础设施，故障时无缝切换？但是ip的切换，对客户端是透明的吗？客户端需要修改对应服务器ip吗？
>
> 还是说类似于VMware，单ip底部物理上基于两块网卡，一块active，一块standby？
>
> 两者区分点？一个属于传输层服务，一个属于物理层服务？？？



如果到达的SYN序号大于前一化身的结束序列号，Berkely实现将给当前处于TIME_WAIT状态的连接启动新的化身（启动新的连接）。它要求服务器执行主动关闭，因为接受下一个SYN的那一端必须处于TIME_WAIT状态。P37

>前一句勉强可以理解（即不在等待2MSL？），后一句为什么接受下一个SYN的那一端必须处于TIME_WAIT状态？？？



保留端口/众所周知端口（0-1023）只能分配给特权用户进程的套接字，即分配该范围内端口的服务器必须以超级用户（root）特权启动；如第一章中服务器端程序，使用13端口，需要```sudo```才可以执行。



少部分客户（非服务器）需要一个保留端口用于客户/服务器认证，如rlogin，rsh，客户会调用库函数rresvport创建TCP套接字，并赋予513-1023端口中未使用的端口，库函数会从1023开始反向查找尝试端口，直到513为止。



fork()之后，套接字端口port不变。



MSS是应用层和传输层之间的属性，MTU是网络层和数据链路层之间属性，MSS经常被设置为MTU - IP首部 - TCP首部 和 接受缓冲区大小 之间的小值，MSS发送前必须考虑MTU大小，从而避免分片。

> 但**MSS目的是告知对端重组缓冲区大小，从而避免分片**，那是不是说MSS实际是IP层通过传输层告知应用层的数据大小？不完全是，只能说MSS会考虑MTU大小。
>
> iPV4规定了最小重组缓冲区，即必须支持的最小数据报大小，那么重组缓冲区是属于网络层吗？超出重组缓冲区大小就分片？
>
> 重组缓冲区和MTU之间又有没有关联呢？重组缓冲区是不是就是接受缓冲区？如果是接受缓冲区，那么之间无关联，一个是主机侧缓冲区大小，一个是链路层受制于硬件等设置的大小。
>
> 可以理解为MSS，MTU是基于主机侧硬件，网络中各路由器硬件所得出的值，而MSS的值在考虑主机缓冲同时，考虑路由器等条件。



TCP套接字中，**write返回只代表可以使用应用进程的缓冲区，不代表对端已收到**(只是说写入到了内核发送缓冲区)，如果发送缓冲区容不下应用进程中要发送的数据，~~应用进程休眠~~，那么write会返回最大能容纳的数据量，所以使用write时需要关注write的返回是否等于想发送的全部数据量；

UDP套接字中，**write返回代表数据报进入了数据链路层的输出队列**；如果队列没有足够空间存放，内核通常返回一个ENOBUFS错误给应用进程。（但有些UDP实现不返回该错误）；



TCP、UDP之间端口相互**独立**。



#### 第三章

ipv4 套接字地址结构<netinet/in.h>：```sockaddr_in```， 地址族 AF_INET

ipv6 套接字地址结构<netinet/in.h>：```sockaddr_in6``` ，地址族 AF_INET6

通用套接字地址结构<sys/socket.h>：```sockaddr``` ，所有套接字函数接受一个指针形式传入的套接字地址，为兼容所有协议族下的套接字结构，使用通用指针（否则就得针对不同协议族写不同的套接字函数），但是当时void* 还未出现，故定义了一个单独的通用套接字结构体（SA），所以每个特定协议族的套接字结构都要强转才能传入套接字函数

新的通用套接字地址结构<netinet/in.h>：```sockaddr_storage ```，可满足地址结构的对齐需求，可容纳系统支持的所有套接字结构



值-结果参数：套接字函数的参数设计思考，如果函数内不需要修改参数的值，只是作为判断条件之类，则传入“值value”；如果函数内需要修改参数的值（如套接字地址长度），并传出交由他人使用，则传入引用或者指向结构的指针，作为返回的“结果result”。



ps：16进制 右边为低位，左边为高位

主机字节序、网络字节序：多字节数据存放至内存时，次序排布 从低位开始，还是从高位开始

大端字节序 big-endian：从高位作为起始位置

小端字节序 little-endian：从低位作为起始位置

主机字节序取决于CPU；TCP/IP套接字发布时，要求网络套接字中发送的多字节数据，使用大端字节序；

本来一个用户透明的转换函数可以解决主机、网络字节序不一致问题，但是不幸，套接字地址结构中的某些字段（如ip、port）使用网络字节序存储，所以在套接字函数中传入参数时，地址结构中的那些字段必须显式的转换为网络字节序，防止发生字节序不一致。

>主机字节序和网络字节序直接显示转换函数如下：
>
>```C++
>#include <netinet/in.h>
>
>//host to network short(16bit)
>uint16_t htons(uint16_t host16bitvalue);
>//host to network long(32bit)，此处long只代表32bit
>uint32_t htonl(uint32_t host32bitvalue);
>
>uint16_t ntohs(uint16_t host16bitvalue);
>uint32_t ntohl(uint32_t host32bitvalue);
>```



同样，字符输入的ip地址和对应网络字节序二进制值之间也需要转换

>函数的返回值类型，不同返回值代表的意义同样重要
>
>ipv4协议下：
>
>```C++
>#include <arpa/inet.h>
>
>//字符串有效，返回1，否则0；结果用addrptr存放
>int inet_aton(const char* strptr, struct in_addr *addrptr);
>//返回点分十进制数串的指针；参数为结构，不是指向结构的指针
>//该字符串在静态内存中，导致函数不可重入；和inet_ntop比较，也可发现
>char *inet_ntoa(struct in_addr inaddr);
>
>//字符串有效，返回网络字节序二进制值；否则INADDR_NONE，但由于INADDR_NONE使用了255.255.255.255对应常值，导致广播地址传入有误，建议使用inet_aton
>int_addr_t inet_addr(const char* strptr);
>```
>
>
>
>伴随ipv6产生(特点：为兼容ipv4，ipv6，都需要指明协议族)：
>
>```C++
>#ifdef WIN32
>#include <tcpip.h>
>#else
>#include <arpa/inet.h>
>#endif
>
>//成功返回1，输入的表达式格式无效返回0，出错返回-1;结果用addrptr存放
>int inet_pton(int family, const char *strptr, void *addrptr);
>//返回指向结果的指针，否则NULL
>const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len);
>```

PS: **转换为网络字节序二进制值的函数返回值，都是1代表有效**；```inet_pton```对输入字符串格式更严格（只接受点分十进制或者ipv6下的对应格式），所以会检查格式，从而0代表无效格式；```inet_aton```可接受多种字符串格式，点分十进制、0x十六进制、0八进制对应的ipv4地址均可。



#### 第四章

##### 一、串联整个TCP连接过程

考虑发起连接的前后准备工作：
1、首先确定本次连接的类型，ipv4还是ipv6、TCP还是UDP等，socket.h中这部分由socket()承担，返回一个套接字的描述符sockfd；

2、针对客户端而言，直接发起连接connect()，因为源IP和port都可以由内核指定，自己指定不是很重要，而connect中需要指定连接的对端地址；

3、针对服务器端，更多的作为一个被动接受连接并做出相应反馈的角色，所以接收到连接之前，要对外提供一个可供客户连接的套接字（更常见的是提供一个众所周知端口），即源套接字，所以bind()承担绑定一个本地协议地址到套接字的任务；有了这个对外提供的接口，还需要打开对应被动接受的服务，或者监听对外服务的接口，即listen()；

4、如果监听到有连接进入，且连接已经完成（三握手结束），那么服务器端就可以给客户反馈信息了，创建新的已连接的套接字accept()，完成相应服务；

5、最后，连接不可能一直开着，故需要close()套接字；但是此处的套接字只是打开计数器减一（套接字就像文件一样），计数减为0才会发起TCP的正式FIN，而且再发起FIN之前，还会将已经排队的发送缓冲区中数据发送完毕（此时如何确定对端明确收到？四挥时附带ACK？），这个属性可以再SO_LINGER这个套接字属性中修改

##### 二、相应套接字函数

（依照功能，参数含义，返回值含义顺序）
```int socket(int family, int type, int protocol);```

指明通信协议；family参数用地址族代表协议族，type参数表示传输的数据类型，protocol参数可由前两个参数推定，返回对应套接字描述符，此套接字默认为主动套接字；

>之前实验中 255.255.255.255广播是无法收到，但是所在子网广播192.168.10.255是可以收到的，setsockopt()设定SO_BROADCAST选项后似乎可以收到？实验！！



```int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen)```

发起连接（三次握手）；sockfd表示socket函数返回的套接字，servaddr表示对端地址信息；返回连接成功与否，成功为0

> 出错情况：
>
> 1. 没有收到SYN 的 ACK，返回ETIMEOUT，并且本端发起重传（重传策略却决于内核）；
> 2. 收到了回应，但却是RST，返回错误ECONNREFUSED，（hard error）;
> 3. 收到了路由器发出的ICMP不可达，先保存ICMP错误，再尝试重传，仍失败则返回EHOSTUNREACH（soft error）
>
> PS： 收到RST的原因
>
> 1. 对端的对应port没有开启该服务进程，或者没有listen
> 2. TCP想取消已有连接
> 3. 收到一个根本不存在的连接的分节segment
>
>
>
> **connect()将会在收到三次握手的第二个分节（SYN+ACK）时返回**
>
> 且connect返回错误，将导致整个sockfd不可用，需要close套接字然后重新从socket()开始





```int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen)```

绑定本地协议地址到sockfd中，作为发出数据报中的源地址信息；myaddr表示本地地址信息；成功返回0

> 没有调用bind和调用bind使用通配符区别：
>
> * 没有调用bind()
>
> port将会在conncect（client）/ listen（server）时，由内核指定；
>
> ip将会在connect（client）/ accept（server）时，由内核（client）/ SYN中目的ip（server）指定；
>
> * bind中使用通配符port/ 通配符ip
>
> port将会在bind时由内核分配；
>
> ip将会在connect（client）/ accept（server）时，由内核（client）/ SYN中目的ip（server）指定；
>
> 以上分配时机，决定了```getsockname()```获取到套接字中本地协议地址和对端协议地址的时间



```int listen(int sockfd, int backlog)```

将未连接套接字变为被动套接字，监听对应端口，设置到达的套接字排队的最大连接数；backlog参数现指定为已完成连接队列的长度，以前版本中此参数为已完成连接队列长度 和 未完成连接队列长度 之和（从而避免了未防止大客户量访问和SYN洪泛攻击而指定一个特大的backlog）；成功返回0；

> 内核为每一个监听套接字维护两个队列，已完成连接队列和未完成连接队列；收到对端发起的SYN，就算做未完成连接，等待RTT时间；完成三次握手即为已完成连接（从未完成连接中转移过来）；如果队列满了，TCP就会忽略到达的新SYN
>
> 如果listen中已完成连接，但还未调用accept，此时到达的数据将会放在对应套接字的接收缓存区中



```int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen)```

从已完成连接队列队头拿出一个套接字，并生成一个全新的套接字描述符（如果没有已完成的连接则默认阻塞）；clientaddr和addrlen参数中将会返回对端的协议地址信息和对应长度，注意调用accept前对addrlen的初始化；返回全新生成的描述符；



```int close(int sockfd)```

关闭对应套接字，如果计数器为0则发送FIN，发送前将发送缓冲区中排队的数据先发送出去；成功，返回0

**对于调用进程而言，读写两个方向全部关闭**



##### 三、其他函数

```pid_t fork(void)```

创建子进程，**在fork()返回之后将会复制（共享）fork调用前的父进程中的所有资源，包含套接字**（子进程是否继承套接字，可设置套接字属性决定fcntl() FD_CLOEXEC）；返回两次，父进程中返回子进程的pid，子进程本身返回0；

> fork用法：
>
> 1.fork出子进程后，父子进程并发执行；
>
> 2. 子进程中调用exec() 执行另外的程序，exec会把当前进程映像直接替换为新程序文件



```int execve(const char *pathname, char *const argv[], char *const envp[])```

执行对应路径下的程序文件；argv参数表示新程序参数，envp参数表示环境参数；成功不返回，失败返回-1；

>exec()由6种形式，但只有execve是内核函数，其他5个本质调用execve；
>
>区别在于待执行程序是路径名还是文件名，程序参数一个一个指定还是由指针数组引用，**调用进程的环境传入新程序还是给新程序指定新环境**
>
>Ps： 如果新程序需要connfd值；则（1）可以把connfd格式化为字符串，作为参数传入；（2）调用exec前指定某个描述符为所接受的已连接描述符



##### 疑问

exec中环境参数如何理解？？和普通参数区分点在哪？



#### 第五章 
（实际程序中的可能故障及处理）

（为解决一个问题，引入一个解决方案，但同时需要解决该解法带来的问题。。。。）

##### 一、多进程TCP程序的正常终止：

客户端发出FIN后（如exit进程，从而触发清除该进程中所有套接字描述符），服务器端的子进程（负责TCP连接建立后的工作）同样终止进程，同时给父进程发送```SIGCHLD```信号，父进程对此信号的默认处理时忽略，从而导致该子进程成为僵尸进程（zombie），而僵尸进程会占用内存空间；如果父进程终止，则这些僵尸进程的父进程重置为init（改变父亲），init程序会清理所有僵尸进程；

> 僵尸进程本身是为了父进程获取其子进程的状态而设置
>
> 收到FIN，会导致read返回0



需要处理的问题：

父进程为处理僵尸进程，所以需要一个信号处置（dispostion/action）机制，发现对应信号即做出相应处理，通常使用sigaction函数来设置处置（sigaction的数据结构较复杂，所以一般把sigaction封装在```void(*signal(int signo, void (*func)(int)))(int)```函数中，提供信号量和信号处理函数即可)，处置可以选择以下三类：

1、提供处理函数，即信号处理函数（signal hander），由对应信号量出现时，即调用该函数，此过程即为信号捕获catching    ```void hander(int signo)```

2、忽略该信号 ```SIG_IGN```

3、默认处置该信号 ```SIG_DFL```

信号处理函数一旦安装，便一直安装着；处理函数运行期间，这个正在被递交的信号量会被**阻塞**；

信号默认**不排队**，即同一个信号量在被阻塞期间（处理函数运行时，sa_mask中选择的信号量和函数对应信号量被阻塞）发生多次，解阻塞后只递交一次，如多个同信号量同时到达，第一个被阻塞，运行处理函数，函数结束，则剩余信号量无法再次触发处理函数。

>**个人理解：**
>
>**信号默认不排队是指，同一信号量在被阻塞期间（如处理函数运行期间）多次到达，在解阻塞（信号处理函数运行结束）后只递交一次，即在处理函数运行期间到达的信号，不会再次触发处理函数；**
>
>**但是！**
>
>**在信号处理函数运行过程中，如：用```while```循环调用```waitpid```，它会检测到其他已终止的子进程（应该不是检测到其他到达的SIGCHLD信号），进而把触发信号的终止子进程全部处理掉（所以可能无法适用于其他信号量处理，所以总的来说信号量的确是不排队的！）。**
>
>（不过与老师说的，内核中每个进程会有一个收到的信号的队列有出入，完全不同！）**



解决方案附带的问题1：

但如果指定了信号处理函数，**触发该处置时会导致原先的运行（或阻塞）的系统调用被中断**，如父进程中的accept()，OS不一定有机制可以使被中断的系统调用重启，为提高移植性和鲁棒性，自己最好处理下这种情况，如手动重启；



解决方案附带的问题2：

信号处理函数内部需要注意事项：wait、waitpid都用来处理已终止子进程，如何选择并使用：

```pid_t wait(int *statloc)``` 处理第一个已终止子进程；如果遇到没有已终止子进程，阻塞

```pid_t waitpid(pid_t pid, int *statloc, int options)```处理指定已终止子进程，且options中可指定遇到无已终止子进程时，选择不阻塞



accept返回前连接中止

如果OS内核不能处理这种异常，则accept返回报错```ECONNABORTED```，服务器端需要重新调用accept

> OS内核处理如果可以处理该异常，将在已完成连接队列中将该连接踢出，并释放对应套接字，应用无感知



##### 二、服务器端异常

1、服务器进程终止

问题1：

如已建立连接后，将对应子进程kill，进程终止时会关闭所有套接字描述符，导致服务端发起FIN，客户端确认；但此时客户端阻塞于```fgets()```等待输入，未感知，当客户端收到输入结束fgets阻塞，进行```write```时（现在只有服务端到客户端方向关闭，客户端到服务器端是允许的），由于服务器端对应进程关闭，所以服务器端发出RST，如果（1）RST在客户端调用read之前到达，会导致read()返回```ECONNRESET 对方复位连接错误```；

（2）RST在客户端调用read之后到达，read返回0；两者均应该关闭客户端一侧所有套接字描述符

> **RST会使连接中止，并阻止连接中止发起方（即先发出FIN的一方）经历TIME_WAIT阶段**；所以后续FIN分节不需要客户端发送，连接已经断了



解决方案：

客户端问题在于，存在两个描述符- - stdin和用户套接字；但fgets使得**进程阻塞于其中某一个特定描述符**，即stdin，从而使得无法立即感知到收到的FIN；后续使用select和poll，进程应**阻塞于任何一个描述符**；当任何一个描述符有变化，即可感知



问题2：**SIGPIPE**

服务器子进程被kill后，write写入套接字（收到RST），如果继续写入，将会收到```SIGPIPE```；另外如果套接字先执行写关闭，然后再次write，会直接收到```SIGPIPE```；

该信号量默认行为是终止进程。而不论信号量默认处置、捕获后使用信号处理函数还是忽略，写操作均会返回```EPIPE```错误。不过该信号量的递交无法得知是哪个套接字出错。



解决方案：

如果不想进程被该信号量终止，需要忽略该信号量或者捕获该信号量，后续捕捉EPIPE错误并终止程序。



（实验，将父进程kill掉，子进程被init接管后，能不能继续正常工作）

2、服务器崩溃（崩溃 != 正常关机）崩溃等同于拔网线或者主机宕机

问题：

建立连接后，服务器端突然崩溃，则所有发送（write）的**数据分节**均无法到达，TCP会尝试持续重传，berkeley实现中会重传12次，共约9min才放弃重传。而客户端阻塞于read()，在底层放弃重传后会收到两种错误，（1）ETIMEOUT（2）若中途路由器判断无法送达，从而返回不可达的ICMP，将返回EHOSTUNREACH或者ENETUNREACH

如果不想一直阻塞于read()，可设置read超时时间

解决方案：

**客户端只有在发送数据后才能发现服务器端故障，如果没有数据交互，则互相发现不了对方崩溃**；所以可加入保活机制```SO_KEEPALIVE```，不一定等到有数据发送时才检测到服务器端状态。



3、服务器崩溃后重启

问题：

延续上一问题，若在客户端**重传数据分节**时，服务器端重启，但此时**TCP丢失了所有的连接信息**，所以服务器响应一个RST，此时客户端阻塞于read，类似之前的1.进程终止时，返回错误ECONNRESET

PS：如果还处于发起连接状态（客户端SYN），服务器崩溃后重启，如果在重传结束前重启，则服务器连接成功。



4、服务器人为关机

问题：

服务器正常关机，在关机时，init进程会给所有进程发送```SIGTERM```，一段时间后（5~20s），给仍在运行的进程发送```SIGKILL```，之后情况和1.进程终止时相同

```SIGTERM```的默认处置是终止进程，```SIGKILL```发送给那些将```SIGTERM```信号忽略的进程，而```SIGKILL```无法被捕获和忽略



##### 三、（考虑）客户端异常

1、客户端进程终止

如果客户端发送对应请求后，进程被kill，其中所有描述符被清除，客户端发起FIN，服务器端确认；

服务器端子进程正阻塞于read()，收到FIN，read返回0，子进程正常终止；

或者客户端进程终止前，服务器端write()已发出，到达前客户端终止，客户端会发出RST，使阻塞在read的服务器子进程返回ECONNRESET

如果在上述情况，第一次write后，客户端终止（产生RST），而服务器端再次write()，产生SIGPIPE信号量，默认处置下，导致子进程被终止！！



2、客户端崩溃（即非终止，FIN等分节均未发出）

~~客户端崩溃会发出信号量，该信号量会导致服务器端进程关闭（一直未复现该状况！！！）~~

（回射为例）如果有数据要传送，write发出后，阻塞在read，而内核会持续重传数据分节，重传若干次仍然失败，read返回ETIMEOUT或者ENETUNREACH；

如果之间没有数据交互，则完全发现不了；所以需要keepalive机制！！



##### 四、网络中传递的数据的格式

网络中发送数据的格式可以是文本，当然也可以是二进制数；

而C\S两端的主机字节序可能不同

操作系统也可能不同，从而对同一数据结构的位数、对齐方式也不同



故：

（1）尽量使用文本串传递（文本串是如何规避以上问题的？？）

（2）发送二进制数时标明字节序、位数、对齐方式等，RPC中常使用这种方式



##### 习题中的疑问

1、daytime服务端，客户端sleep()为什么会导致daytime服务器发送应答（什么应答）并关闭连接？？？？

2、文本串是如何规避大小端问题？？

Array elements are always addressed from low to high, regardless of endianness conventions.

ASCII and UTF-8 strings are arrays of , which is not a multibyte type and is not affected by endianness conventions

[c - no big endian and little endian in string? - Stack Overflow](https://stackoverflow.com/questions/62001896/no-big-endian-and-little-endian-in-string)

3、**SIGPIPE的产生机制必须是对已断连接进行两次write，才产生吗？**

P114

是的；必须两次，第一次导致对端发出RST，第二次产生SIGPIPE信号



#### 第六章

##### IO模型汇总

以输入为例，应用进程```read()```获取到输入信息分两阶段：

（1）等待数据到达内核接收缓冲区

（2）从内核缓冲区复制到进程缓冲区

以下模型，在这两个阶段有着不同的处理

| 阻塞IO                                     | 非阻塞IO                                    |
| ---------------------------------------- | ---------------------------------------- |
| 两阶段均发生在read()系统调用时期；read()会一直等待数据到达，并完成复制任务 | read系统调用时检查数据是否到达，未到达直接返回错误，到达了就复制到进程缓冲区；所以一般会做read的循环调用，直到读到数据为止 |



| IO复用                                     | 信号驱动IO                                   |
| ---------------------------------------- | ---------------------------------------- |
| **主要针对同时存在多个描述符（不局限于套接字描述符）**；如果进程阻塞在其中某个描述符，会漏掉其他描述符在此阻塞期间的信息；所以引入一个集中的”阻塞管理器“-- select/poll，等待数据到达阶段全部发生在```select()```，满足其中任一条件再往下走，read()等系统调用只做第二阶段的工作 | 进程不会被阻塞，但需要搭配信号处理函数 signal handler，出现对应信号量，才执行对应系统调用（这个系统调用可以在handler里执行，也可以留给进程主程序完成）；换言之，内核监控需要的数据情况，而进程本身无影响 |



| 异步IO                                     |
| ---------------------------------------- |
| 前四种模型，第二阶段的处理均由进程自身完成，而异步在于所有阶段都由内核搞定，通过提供的异步函数（传入进程缓冲区指针等必要参数），把等待数据和第二阶段的系统调用全部完成，完成后通知进程即可，进程也不会发生任何阻塞 |

##### 疑问

信号驱动IO中，信号量的粒度是怎么做的？

即我怎么知道在遭遇什么情况时，会产生什么样的信号量，而这个信号量会不会对应着两种事件的发生，比如会不会出现有个信号量SIGX，同时对应有读和写事件，那么signal handler里到底执行read还是write？

**可能要深入到OS内部信号量产生**（待解答，先把这本书看完，看会不会有答案）



##### select

1、select函数

（依照功能，参数含义，返回值含义顺序）

```C++
int select(int maxfdp1, fd_set *rset, fd_set *wset, fd_set *eset,
const struct time_val *timeout)
```

阻塞在以上任意一个描述符集中，满足其中任何一个条件即返回，描述符集分为读集、写集、错误集；

```maxfdp1```表示待测试的描述符个数，其实是关心的描述符的上限，而所关心的描述符的数量 = 上限 + 1；因为描述符从0开始计；

```rset\wset\eset```分别表示关注的输入、输出、异常状态的描述符集合；**描述符集在内核中**

```timeout```表示```select()```阻塞的时长，可以为永远等下去，即该值为空指针```nullptr```；等待一段时间；或者根本不等待，该值为0，即检查描述符并立刻返回，也就是轮询；

返回值表示满足条件的描述符的数量，如果某一描述符同时满足读、写，则会计算两次；如果超过timeout仍无满足条件的描述符，则返回0；出现错误则返回-1；

> 此处的```fd_set```使用了value-result参数，即传入的值和返回的结果集成在同一个变量上，造成的后果是循环中每次开头需要重置该值！
>
> 且```fd_set```是个整数数组，但是每个整数按照位来查看，按照顺序，每一位代表一个fd；
>
> 以上两点和poll函数完全不同。

>timeout值在不同系统中实现略有不同，如windows系统中timeout是常值，即使超时时间已过，select返回后，该值也不变；而在linux实现中，该值为select返回后的剩余时间





**2、描述符就绪条件（达到倒背如流程度）**

不同描述符集（主要是套接字描述符）分别在什么情况下，才算“就绪”

个人理解：满足条件可以从正常读写、结束读写、套接字里有错误三个角度大致分类；剩余为特例

（1）满足以下任一，套接字准备好读

a) 接收缓冲区有足够数据，数据量大于标记的低水位

b) 该连接进入读半步关闭，即收到对方FIN；read时返回0

c) 套接字里有错误待处理，read时返回-1

d) 该套接字是监听套接字，且已完成连接数不为0

（2）满足以下任一，套接字准备好写

a) 发送缓冲区有足够空余空间，空余空间大于标记的低水位；并且已连接或者不需要连接（UDP）

b) 该连接进入写半步关闭，即主动发出FIN，对这种套接字再write会触发```SIGPIPE```

c) 套接字里有错误待处理

d) 使用非阻塞的connect的套接字已建立连接（通知可以发送数据了）或者connect已经失败

（3）满足以下，套接字有异常需要处理

套接字存在带外数据？或者仍处于带外标记



##### poll

和select非常类似，内部实现有差异

```int poll(struct pollfd *fdarray, unsigned long nfds, int timeout);```

阻塞在传入的描述符数组上，任何一个描述符的events满足，则返回；

fdarray是描述符数组，nfds是数组元素个数，timeout可设置超时时间，单位为ms；

返回值表示满足events条件的描述符的数量；如果超过timeout仍无满足条件的描述符，则返回0；出现错误则返回-1；



主要区别在于fdarray，它是个结构体pollfd数组，每个pollfd代表一个套接字描述符，且pollfd中对传入的值和返回的结果拆分，放置在两个变量上，所以不需要每次都重置

```C
struct pollfd
{
    int fd;//套接字描述符
    short events;//传入的值，即指定需要满足的条件
    short revents;//返回的结果，即对于指定条件是否就绪的返回，0即未就绪
};
```

如果fd成员为负值，poll会忽略该fd，并且将revents成员置为0



##### shutdown

```int shutdown(int sockfd, int howto);```

不管引用计数，直接触发TCP的正常连接终止（开始四挥）；且可以设置关闭具体哪个方向的连接；

```int howto```可以为```SHUT_RD```关闭连接的读一半、```SHUT_WR```关闭连接的写一半、```SHUT_RDWR```读写均关闭；

成功则返回0，否则返回-1

##### 批量输入

混合使用函数内置缓冲区和select会导致select无法观察到自制缓冲区内有无数据，从而阻塞，需要避免此情况（select只监控内核中的套接字的接收和发送缓冲区？）

##### 拒绝服务型攻击

服务器处理多个客户进程时，绝对不能阻塞于只与某个客户相关的某个函数调用中，否则会导致服务器被挂起，拒绝为其他客户提供服务。

解决方案：

1、使用非阻塞IO

2、使用多进程或多线程服务器

3、为IO操作设置超时时间





##### 疑问

1、内核中是为每个套接字分配接收和发送缓冲区，然后拷贝到用户态中套接字各自的缓冲区？（个人倾向于这种，很多实现也在印证这种）是，内核内和套接字一一对应

~~还是说内核具有一个大的统一的接收和发送缓冲区，而用户态中每个套接字又有自己的缓冲区？~~

2、select监控的是内核中缓冲区还是用户态中各自的缓冲区

内核



#### 第七章

套接字选项获取与设置

##### getsockopt && setsockopt函数

```C++
int getsockopt(int sockfd, int level, int optname, void* optval, socklen_t* opelen);
int setsockopt(int sockfd, int level, int optname, const void* optval, socklen_t optlen);
//成功返回0；其他返回-1
```

分别用于获取和设置套接字sockfd中的具体选项信息；

```level```指明了设置的选项的级别（或者理解为所属的类型，毕竟套接字选项太多了，分个类好管理），分为通用、IPV4、IPV6、ICMP、TCP几大类，主要关注**通用、ipv4和tcp**即可；

选项又可根据其可设置的值类型，分为标志选项和值选项，标志选项即二元选项，只有启动和关闭两类，C语言标准非零即启动，0即关闭；值选项意味着可以设置选项为某个特定值；

```optval & optlen```在getsockopt时为返回的具体选项的当前值，所以optlen为值-结果类型；在 setsockopt时为实际可设置的值，所以optlen为值类型，optval均使用void*是为了兼容各种选项类型；所以设置时可能需要强转为```void*```；

##### level  & optname 套接字级别及下属选项名称

以下均为个人理解，一些细节不赘述

注意选项的继承

如**已连接套接字会继承监听套接字中的以下选项**：

LINGER、NODELAY、KEEPALIVE、RCVBUF、SNDBUF、MAXMSG、DONTROUTE等

###### SOL_SOCKET

1、SO_BROADCAST

只用于UDP，开启广播，（难怪当时tcp，设置了广播有问题，面向连接的协议根本没法广播 -_-!）

2、SO_ERROR

**套接字产生的错误**，不一定会用来初始化全局变量errno，但**肯定记录在套接字自身的so_error上**！也就是待处理的错误，select可读写就绪条件之一！**getsockopt之后，so_error会被复位为0**

> 调用read时，没数据返回且so_error非0，read返回-1，才会用so_error赋值errno，随后so_error复位；
>
> 调用write函数时，so_error非0，write返回-1，才会用so_error赋值errno，随后so_error复位；

3、SO_KEEPALIVE

用于主机一级的活跃检测（没动静2小时，就间隔发送探测分节），不是进程一级的，也即是说应对进程崩溃，该选项无效；并且无法区分主机故障和主机连通性暂时丢失

4、**SO_LINGER**

**针对```close()```时，套接字的发送缓冲区内残留的待发送数据处理方式，以及```close()```返回的时机（接收缓存区内数据一般都是直接丢弃）**

**收到对端的ack确认**，不代表对端已经读了该部分数据，**只代表对端接收缓冲区收到了该数据。**

> **listen()前设置linger，之后产生的已完成连接中，（windows中）不会继承该选项；但linux会继承该选项！！**
>
> ![image-20211220212539094](C:\Users\Zhong\AppData\Roaming\Typora\typora-user-images\image-20211220212539094.png)

5、SO_RCVBUF & SO_SNDBUF

可设置接收和发送缓冲区的大小（字节）；因为缓冲区大小是在SYN时，两侧套接字间做的沟通，所以需要connect\listen前完成该选项

6、SO_REUSEADDR & SO_REUSEPORT

主要针对端口的复用（考虑单播、多播、广播场景），因为正常情况下，一个正在使用的端口，再绑定bind该端口会报错（不论是同一ip还是其他ip，不论同进程还是其他进程绑定），所以**bind之前设置该选项**

###### IPPROTO_IP

###### IPPROTO_TCP

1、**TCP_NODELAY**

禁用Nagel算法，适用于服务器端接收数据多，而返回给客户端数据少的情况，及 需要把单个逻辑请求拆分成多个小分组发送的程序

>Nagel Algorithm:针对小分组（小于MSS的所有分组），收到确认后才能发送下一个小分组；这样再等待上一个小分组确认时，小分组可以合并起来一起发，但随之带来时延
>
>delayed-ACK Algorithm:尽可能（等待个50~200ms）不单独的发送ACK确认，而是捎带确认

2、TCP_MAXSEG

设置MSS大小，连接前get到的该值为默认值，连接后get到的该值为SYN沟通后确定的MSS值；只能减少不能增加

##### fcntl函数

```int fcntl(int fd, int cmd, ... /* int arg */);```

可用于设置各种描述符的控制操作，设置非阻塞式IO、信号驱动式IO、获取和设置描述符属主（可为进程id也可是进程组id），即设置接收SIGIO、SIGURG信号的进程

cmd分别为```F_SETFL```、```F_GETFL```、```F_GETOWN```、```F_SETOWN```；对应的操作有```O_NONBLOCK```、```O_ASYNC```

成功返回取决于cmd，失败返回-1



**开启和关闭非阻塞式IO标准操作：**

```c++
int flag;
//先获取已有文件状态标志
flag = fcntl(fd, F_GETFL);
//O_NONBLOCK 与 已有文件状态标志做逻辑或，防止直接设置NONBLOCK把已有文件状态标志清除
flag |= O_NONBLOCK;
//设置NONBLOCK
fcntl(fd, F_SETFL, flag);


//Error set nonblock
//会把原有的文件状态标志清除！
fcntl(fd, F_SETFL, O_NONBLOCK);


//已设置非阻塞情况下，关闭非阻塞IO
flag &= ~O_NONBLOCK;
fcntl(fd, F_SETFL, flag);
```





#### 第八章 

UDP套接字编程--回射程序为例



```C++
#include <sys/socket.h>

ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags,
                 struct sockaddr *from, socklen_t *addrlen);
ssize_t sendto(int sockfd, void *buff, size_T nbytes, int flags,
              struct sockaddr *to, socklen_t addrlen);
//成功返回读或写的字节数，失败返回-1
//recvfrom读取时不会返回超过一个数据报大小的数据
```



udp无连接省去一大堆麻烦事，sendto、recvfrom时执行连接，发送数据报，并且允许发送0的数据包（也就是说**recvfrom返回0是正常的**），未bind地址和端口值时，内核分配也发生在sendto时；不过也导致udp需要对响应信息的地址来源进行检测，而且没有流量控制，发送过快，接收缓冲区很可能被淹没```netstat -s -p udp```；另外产生异步错误之后，所在进程无法得知，除非是已连接套接字。



> PS：recvfrom函数默认是阻塞的，但是如果在recvfrom之前调用bind，并且bind失败，而代码中又没有设置因此错误退出程序，将会导致**recvfrom变为非阻塞式**！！



##### connect()

为了绑定一个指定的对端ip地址（即发送到这个对端ip，然后只接收这个ip发送过来的数据报），udp可以使用connect()，使用connect后的udp套接字即为**已连接的udp套接字**；而udp套接字使用connect其本质是：connect函数检查套接字内有无异常，如果有，返回给进程，同时复制函数参数中的对端地址信息，之后的sendto和recvfrom中无需写入地址参数（NULL即可），直接使用该地址信息（同时已连接udp套接字可以使用write、read、send、recv），并且所在进程也可以收到返回的异常信息；

| 套接字类型   | write或read   | 不指定目的地址的senndto | 指定目的地址的sendto |
| ------- | ------------ | --------------- | ------------- |
| TCP     | 可以           | 可以              | EISCONN       |
| UDP，已连接 | 可以           | 可以              | EISCONN       |
| UDP，未连接 | EDESTADDRREQ | ENOTCONN        | 可以            |

udp中connect会在指定对端地址后，路由选择一个最适合的本地ip，根据这一特性可以知晓发送至某特定地址的本地ip（```getsockname```）；



已连接udp套接字如果**不会接收**对端其他IP地址和/或端口号发送过来的数据报，可能投递给同主机上的其他UDP套接字。

也就是说调用connect后的udp已经变为了**点对点**的udp。



###### 性能

默认的未连接udp套接字发送多个数据报时，每一个数据报对应一次“连接-发送-断开套接字”操作；

而已连接udp套接字对多个数据报，只有一次连接，即 ”连接-发送1-发送2-···“（没有断开！）



> 所以UDP中引入connect的主要原因在于：
>
> **1、提高发送性能，理由如上**
>
> **2、并发系统中提高udp连接稳定性**
>
> 如某客户端A和服务器B、C均有udp连接，而B、C提供相同服务，为实现简单的负载均衡，B、C交替提供服务，但是由于时延等原因，A在等待接收B的回复时先收到了C的回复，导致错误！
>
> 此时可以创建两个udp fd，每个fd分别与B、C主机建立connect的udp，这样就变成了两个点对点的udp，之后使用交替发送即可，接受时根据fd区分即可。

##### 多次调用conncect()

作用有二：

重新指定新的IP地址和端口；

断开套接字



##### 其他

不同于tcp常采用的多线程/多进程，处理不同客户端的进程内的套接字拥有属于自己的接收，发送缓冲区；udp一般采用迭代式，处理不同客户端的套接字接收缓冲区是同一个，数据报到达之后是排队的；而udp的发送缓冲区类似虚拟的，没有实质的发送缓冲区



udp套接字中，如果进程需要**获知目的IP地址**（也就是通过数据报知道自己的地址信息），只能通过ipv4设置**IP_RECVDSTARDDR**选项，然后调用**recvmsg**取得，不过目的端口和TCP一样，通过getsockname可知。



#### 第十一章

ip地址到主机名的互相转化





#### Trick

1、判断非阻塞连接的fd_set，一般把读、写集都加上去；

2、单个连接上，（不频繁的）问答式的可使用阻塞式IO

3、gethostbyname是阻塞函数

4、线程级别的信号屏蔽！！（因为线程会共享进程的部分资源，所以线程级别的保护很有必要）

5、不同主机间（尤其主机字节序不同的）通信，数据格式要么选择告知对应格式，然后明确转化；或者直接使用字节

6、C++中delete和delete[] 后面都是跟一个指针，但区别在于delete默认析构并释放这个指针指向的地址空间，而不管这个指针后面其他数据，这在指针实质是个数组是明显不对，因为相当于只释放了arr[0]的地址，其他部分没变；所以需要delete[]告知编译器，这个指针代表一个数组，除了当前指针，还需要关注后面的地址空间

7、关注信号量是否排队问题？？？到底是什么



