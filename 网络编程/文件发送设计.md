已废弃

功能：将某确定路径中的文件发送至另一台服务器中



步骤：

1、根据路径，打开文件

考虑减少IO尽量只打开一次，但是如果文件过大，只打开一次然后全部放入内存不现实；根据文件大小，设为两种模式？

一种单次IO，一次性获取所有文件数据；一种多次IO，每次获取n*64k的数据

2、数据发送（先只考虑单次io）

获取到文件数据后，根据64k为一块，切分为若干块；发送数据前，先发送本次即将发送的块数（单独的一个包），作为接收方的接收结束鉴别

发送时，以数据块为单位，pushback进发送队列（加锁，确保线程安全），然后发送队列逐个放入一个申请的Cache中，Send数据Cache中的数据即可

问题：在触发的一次写就绪中，循环的将一个块发完即停（即一个Cache）还是全部发送队列

A：应该是全部发送队列，否则的话效率太低！！并且除非内核缓冲区忙，即send 返回0，需要等待下次写就绪再发送，否则尽可能本轮循环发出

> 似乎和现有的paxos发送流程不同，paxos是msg写入消息队列，然后消息队列将其加入到发送队列，发送队列直接发；可能需要改Connection::HandleWrite

3、接收方接收

接收方首先解第一个包，获知块数量；然后循环获取所有块，等块接收完毕后，重新组成文件内容

4、新建文件



包结构设计：

[目的存储路径 path，类型，本块大小 len，offset，content]

类型用于区分 通知块数量的包还是正常的数据包



文件类 - 切分文件为块：

```C++
char *content；//内容
vector<char*> blocks;//块容器

int fileSize;
int blockSize;//default = 64 * 1024

void BuildBlocks(char *content, vector<char*>& blocks, int blockSize = 64 *1024);
```







问题：

1、无限追加：即使文件已经存在，再次运行也会追加，所以多次运行，内容会重复

2、文件名：目前文件名是单一指定的，后续如果要多个文件，应该有文件名自动生成，如clone001，clone002等，类似leveldb

3、当前策略，一次性把所有文件内容读进内存。不是很适宜

4、文件名fileName使用未初始化指针，debug直接出现文件访问冲突问题，改为char []解决。（此问题需要深究）

5、发送队列中的每个block发送前，需要加上引导头等，所以在栈上开辟了一个内存缓存原有的内容，但是这样的话，内存没有回收，有内存泄露风险

6、现有策略下，如果一个文件100k，而设定的block为64k，即该文件会被分为两个block读入并写到发送队列等待发送，但是，用户态的接收缓存设置长度仅为10k，所以streamproc中需要多次recv才能凑到一个完整的block（这还是网络一切顺利，每次能收满10k的前提下），而凑一个完整的block，这一过程有问题。

目前通过更改block大小为10k-28（引导头等大小），使得每次接收端recv一次即为一个block解决，但不是长久之道，里面绝对存在问题！！

![streamproc单包处理流程](F:\Markdown\研一上\图片\streamproc单包处理流程.png)

这个流程里，每收到一次报文，将收到的长度和报文前端的长度信息比对，以确定收到了完整的包；但是测试时，新增到streamProc的buff似乎有问题，报文结构被破坏了，引导头等信息直接被刷掉了

A：反复debug发现是streamProc的默认最大数据段长度maxSegLen_过小导致。。



7、收到的文件中文乱码

8、未实现最初的先发block数量的设计（类似控制报文），测试时文件大小并不大，但这个需要加上，否则根本不知道接收的全不全

9、线程安全问题：尤其是计算block的时候





文件名最好，带到包里面发过来，然后收端的文件名和发端一致











快照收发流程：

主线程调用文件发送函数，通知向其他节点发送快照文件（或目录），本函数发送完所有的快照文件后，再次通知主线程；

则需要启动新的线程，每次按block为单位发送，直到文件发送完毕；因为要保证收方和发送方的文件名一致，且文件名长度未知，所以发送内容块之前，将文件名作为一个单独的包发送；之后发送n个块，文件内容全部发送完毕后，最后发送结束包；作为收到文件名包和结束包的回应，接收方需要发送对应的回应消息，收方得知结束包的确认回复后，跨线程通知主线程，此快照文件发送接收流程完毕



发送方：

线程启动后，存在三种类型的包，即文件名包、内容块包、结束包

内容包的发送是由接收方发来的文件名包确认来驱动，而文件没有读完，就继续发送新的内容块

上一个内容块发送完毕后，才可以发送下一个内容块；但是如果放入发送队列发送，那么内容的放入和发送是两次loop才完成



接收方：

收到文件名类型包后，则新建文件，并保存该路径用于之后的内容写入；收到内容块后只需要继续写入之前的文件即可；收到结束包后，发送确定包



文件操作类：文件的新建、移动读指针等操作

文件发送类：

文件接收类：

通用传输类：



