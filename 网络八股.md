TCP、UDP比较

| 区别        | TCP                                      | UDP                                  |
| --------- | ---------------------------------------- | ------------------------------------ |
| 连接        | 有连接，传输前先连接                               | 无连接，即刻传输                             |
| 服务对象      | 一对一                                      | 一对一、一对多、多对多                          |
| 可靠性       | （传输层的）可靠；不丢失、无重复、按序到达                    | 不可靠，尽最大努力交付                          |
| 拥塞控制、流量控制 | 有                                        | 无                                    |
| 首部开销      | 至少20字节（无选项字段）                            | 8字节，固定                               |
| 传输方式      | 流式传输，字节流，无边界                             | 一个包一个包传输，有边界                         |
| 分片        | 传输层如果超出MSS即分片；目标主机收到后在传输层组装，中途数据丢失则只传输此分片 | 网络层中如果超出MTU即分片；目标主机收到后在网络层组装，然后交给传输层 |
| 常见应用      | FTP、HTTP/HTTPS、TELNET                    | DNS、SNMP、音视频传输、广播通信                  |
|           | TCP的可靠仅指传输层的可靠，保证从发送端的传输层发送到接收端，但是从传输层到应用层并不属于TCP范围，也不负责 |                                      |



## TCP

### 为什么是三次握手？不是两次、四次？

![TCP三次握手](.\图片\网络八股\TCP三次握手.png)



* 三次握手可以防止**历史连接**的建立

假设使用两次握手连接，客户端发送SYN报（90）因网络阻塞未到达，此时客户端重新发起连接，发出新的SYN（100）报，这时旧的SYN（90）报到达服务端，服务端发出ACK（90+1）报，确认旧的SYN，如果使用二次握手即连接，此时服务端可以发送数据，当客户端收到旧的SYN的ACK，发现不是自己需要的ACK（100+1），故发送RST报文，导致服务端发出的数据完全浪费；

而在三次握手下，因未建立连接此时服务端不能发送数据，发出的旧的SYN的ACK会收到RST，从而避免了资源浪费。

而如果在RST报到达服务端之前，服务端收到新的SYN（100）报，此时的服务端会发送challenge ack报文给客户端，此ACK的内容为（90+1），这是因为还没收到RST，服务端认为还是原来的连接，客户端收到此ACK（90+1）后再次发送RST。

* 同步双方的初始序列号

初始序列号对于报文的有序到达、去重复、标识数据包非常重要，所以需要在客户端和服务端之间达成一致，沟通双方的初始序列号，此过程至少需要三次传输，如果使用四次造成浪费。

> SYN 的全称就叫 *Synchronize Sequence Numbers*（同步序列号）

* 避免资源浪费

假设使用两次握手连接，类似1中的历史连接将会导致服务器端分配多次连接，造成资源浪费。



### 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？

初始序列号：$初始序列号ISN = M + F(localhost, localport, remotehost, remoteport)$，其中M表示计时器，F是哈希算法，参数为四元组

* 尽可能避免历史报文被下一个相同的四元组连接接受（只是尽可能避免，不是完全，因为**序列号**还有**回绕**问题，所以实践中会结合TCP时间戳）


虽然TIME_WAIT阶段可以避免历史报文出现，但是仍然有大量情况下TIME_WAIT被跳过，而历史报文的接收需要序列号恰好在接收窗口内，如果每次初始序列号都相同，序列号恰好在接收窗口的几率会很大。

开启时间戳选项（默认开启），连接双方会维护一个最近一次收到数据包的时间戳，如果收到的新数据包小于该值，则认为数据包已经过期，直接丢弃，Linux中称为**PAWS机制**。

不过**时间戳**同样存在**回绕**问题。

* 安全性，防止有人伪造相同序列号的TCP报文


> pre-host 的PAWS机制
>
> 4.12版本前的Linux：在服务端如果开启了`tcp_tw_recycle（不是tcp_tw_reuse--针对连接主动发起方）`  以快速回收服务端主动关闭时的`TIME_WAIT`连接（前提：开启了时间戳），服务端会依据对端IP来判断是否为同一连接（不是四元组，所以导致了后续问题），所以如果是通过NAT发出的数据，对端IP全部相同。
>
> 假设场景：A客户端的时间戳小于B服务器的时间戳（因为时间戳与本机时钟有关），当服务器主动关闭了与B服务器的连接，进入pre-host PAWS，再次收到A的报文时会认为处于同一连接，且时间戳较小，视为过期数据，直接丢弃。故4.12后的Linux版本废弃了此参数。



### 已经建立连接的TCP，收到SYN，如何处理

前提：如果TCP连接已经建立，而客户端意外崩溃，重启后再次发起连接

首先分为两种情况

* 收到的SYN和之前连接的四元组不同--源port不同

此类情况是最常见的，因为客户端一般不会绑定端口号，而是内核随机选择，所以新的SYN中的源port大概率不同，此时接收方会视为另一个全新的连接。

而如果服务端使用旧连接向客户端发送数据，客户端将会恢复RST，因为旧连接已经不存在

* 收到的SYN和之前连接的四元组完全相同

![再次收到SYN](.\图片\网络八股\再次收到SYN.png)

服务端处于`ESTABLISHED`状态的连接收到此SYN后，会首先检查序列号是否在接收窗口内，不在则丢弃，然后检查RST选项，是RST则丢弃，不是RST则接着判断是否为SYN包，然后回复一个携带正确序列号和确认号的ACK（继续延续之前连接的序列号和确认号，必然和此次的SYN不匹配），客户端收到此ACK后，发现确认号和自身发出的SYN不匹配，遂发送RST给服务端，从而连接关闭。服务端到发送的此ACK称之为`Challenge ACK`。

PS：**检查序列号在不在窗口永远是第一位**

### 第三方如何关闭TCP连接

第三方如果要关闭连接，最好的方式是向两端发送”伪装“的RST包，但是RST包的序列号需要和连接两端的期望序列号匹配才可以。

所以可以主动发送同四元组的SYN报文，利用上方提到的Challenge ACK获取所需的序列号，然后再伪造RST，killcx工具即此原理，因为是主动获取双方序列号，所以适用于活跃与不活跃的TCP连接；

另一种方式是利用正常的传输报文，获取双方期望序列号，然后伪造RST报文，tcpkill工具即基于此原理，但是由于是被动获取双方期望序列号，所以仅适用于活跃的TCP连接。



### 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

假设不存在MSS，仅存在MTU，那么当发送的数据大小超出MTU时，IP层需要分片传输，并在接收方的IP层组装并上交给传输层。但是，**IP层本身没有超时重传等可靠性措施**，一旦某个分片传输时丢失，那么IP层无法组装完成，从而无法上交传输层，传输层迟迟无法发出ACK，导致对端的传输层触发超时重传，但此时传输层重传的数据量仍然超出MTU，部分分片的丢失，导致了全部报文的重传！传输效率低下。

所以为了达到最佳的传输效能 TCP 协议在**建立连接的时候通常要协商双方的 MSS 值**，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。

经过 TCP 层分片后，如果一个 TCP 分片丢失后，**进行重发时也是以 MSS 为单位**，而不用重传所有的分片，大大增加了重传的效率。

> MTU：从数据链路层的角度看，MTU为数据链路层的数据段长度，即去掉MAC头部后的总长度
>
> MSS：从传输层的角度看，MSS为传输层的数据段长度，即TCP段去除头部后的总长度

![MSS&MTU](.\图片\网络八股\MSS&MTU.png)

### 三次握手报文丢失的处理

报文丢失之后的处理均为重传，但是区别在于：第一次握手的SYN报文、第二次握手的SYN-ACK报文如果一直没有收到对应的ACK都会重传，而第三次握手的ACK报文如果丢失，将触发第二次握手的SYN-ACK重传，**ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文**。

而每次重传的次数由操作系统内核参数确定

```bash
cat /proc/sys/net/ipv4/tcp_syn_retries
cat /proc/sys/net/ipv4/tcp_synack_retries
```

通常情况下，每次重传的超时时间为前一次超时时间的2倍，如第一次超时重传为1s后，第二次超时重传为2s，第三次4s，第四次8s，第五次是在上次重传16s后。结束五次重传之后，还会继续等待32s，仍然没有收到ACK才会终止三次握手。

这些都是在传输层层面所做的操作，应用层并不知晓，所以可以针对性的修改重传次数，加快把错误暴露给应用层。

### SYN攻击及避免

假设攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会**占满服务端的半连接队列**，使得服务端不能为正常用户服务。

半连接队列：收到第一次握手报文后，放置到半连接队列

全连接队列：三次握手完成后，放置到全连接队列

`listen()`系统调用后，服务端开启监听，此时收到的第一次握手均会放置到半连接队列，而`accept()`会从全连接队列中取出连接对象。客户端调用`connect()`后会发出握手报文，当三次握手结束，则返回（阻塞模式下）

不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，**默认情况都会丢弃报文**。

SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样**当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃**，导致客户端无法和服务端建立连接。



#### 避免

* 调大 `netdev_max_backlog`

当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值的参数即为`netdev_max_backlog`；

* 增大半连接队列

以Linux内核2.6.32为例，通过**同时**

增大 `net.ipv4.tcp_max_syn_backlog`；

增大 `listen()` 函数中的 `backlog`参数；

增大 `net.core.somaxconn`

实现半连接队列的增大

> `int listen(int sockfd, int backlog);`
>
> 其中参数`backlog`最早代表半连接队列的大小，Linux内核2.2之后，`backlog`代表**已完成连接队列**的大小。
>
> 不过已完成连接队列的实际值收到内核参数`net.core.somaxconn`的限制，所以**已完成连接队列**的大小 = `min(somaxconn, backlog)`;



* 使用`tcp_syncookies`

`tcp_syncookies`的作用为收到SYN报文之后，即使半连接队列已满也不丢弃，而是生成一个cookies值，将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端；服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「 Accept 队列」。

`tcp_syncookies`有三个参数值可选，0-关闭，1-当半连接队列已满时开启，2-无条件开启

```bash
echo 1 > /proc/sys/net/ipv4/tcp_syncookies
```

但是cookies值的形成本身需要消耗服务器CPU算力，所以如果恶意客户端随意模拟cookies值然后再第三次握手报文最终发送出来，服务端将会消耗算力做解码，同样可能造成ACK攻击。

* 减少`SYN-ACK`重传次数

由于SYN攻击时，攻击方不会回应ACK，即第三次握手报文，服务端会认为SYN-ACK报文丢失，从而不断重传，达到重传次数上限才会断开连接，所以可以减少SYN-ACK报文重传次数从而加快断开连接。



### 关闭连接

![四次挥手](.\\图片\网络八股\四次挥手.png)

注意：**主动关闭连接的，才有 TIME_WAIT 状态**

### 为什么是四次挥手

关闭连接时，客户端发出`FIN`，表示客户端不再向服务端发送数据，但还能够接收服务端的数据，服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

所以通常`FIN`和`ACK`不会合成一个报文，故需要四次挥手；不过特殊情况下，也可以变为三次挥手。

### 挥手报文丢失

如果挥手报文丢失仍然是重传。

* 第一次挥手报文如果丢失，将会超时重传，如果超出重传上限仍未能收到对应的`ACK`，则会等待一段时间（上次超时时间的2倍），如果还是未收到`ACK`，则**直接进入`CLOSE`状态**。重传次数由`tcp_orphan_retries`决定；

* 第二次挥手报文丢失，因为`ACK`不会重传，所以和第一次挥手丢失情况相同。

因为接收到`ACK`报文后进入`FIN_WAIT_2`状态，如果是因`close()`触发的关闭连接，则客户端（主动关闭方）不会一直等待服务端的`FIN`报文，而是等待一段时间后，如果没有收到`FIN`报文，将会直接关闭进入`CLOSE`状态。等待的时间段由`tcp_fin_timeout`决定，默认60s。

而如果是因`shutdown()`函数关闭连接，且指定了关闭发送而不关闭接收，则客户端（主动关闭方）会一直处于`FIN_WAIT_2`状态，直到收到来自服务端的`FIN`报文为止。此时`tcp_fin_timeout`无效。

> 如此就和《unix网络》书中对close()的解释对应了，书中表示close()关闭的连接，将不能发送和接受请求，所以`FIN_WAIT2`状态不会一直等待。





当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 `ACK`，同时连接处于 `CLOSE_WAIT` 状态，顾名思义，它表示等待**本方的应用进程**调用 `close()` 函数关闭连接。因为此时内核是没有权利替代进程关闭连接，必须由进程主动调用 `close()` 函数来触发服务端发送 `FIN` 报文。

服务端处于 `CLOSE_WAIT` 状态时，调用了 `close()` 函数，内核就会发出 `FIN` 报文，同时连接进入 `LAST_ACK` 状态，等待客户端返回 `ACK` 来确认连接关闭。

* 第三次挥手报文丢失，如果迟迟收不到对应的 `ACK`，服务端就会重发 `FIN` 报文，重发次数仍然由 `tcp_orphan_retries`参数控制，这与客户端重发 `FIN` 报文的重传次数控制方式是一样的。

因为客户端（主动关闭方）如果因`close()`调用而关闭，则不会一直处于`FIN_WAIT_2`状态，可能已经关闭了连接，所以服务端（被动关闭方）在一直未收到`ACK`报文下，会进入`CLOSE`状态。





* 当客户端（主动关闭方）收到对端的`FIN`报文，会进入`TIME_WAIT`状态，并维持`2MSL`时间，并发出`ACK`报文回应，如果此报文丢失，则服务端（被动关闭方）由于长期未收到`ACK`，会重传第三次的`FIN`报文，所以重传规则如第一次。

客户端（主动关闭方）如果收到对端的`FIN`报文，将会重置定时器，重新等待`2MSL`时间。

### 特殊的关闭状态 -- CLOSING

状态`CLOSING`一般不会出现，但是当客户和服务端同时关闭连接时，此状态便会发生。两端同时发出FIN报文进入`FIN_WAIT_1`，并等待对端ACK，此时收到对端的FIN报文，则各自回复ACK，进入`CLOSING`状态，收到ACK后直接进入`TIME_WAIT`状态。

![CLOSING状态](.\图片\网络八股\CLOSING状态.png)





### 为什么 TIME_WAIT 等待的时间是 2MSL

`MSL`即$Maximun Segment Lifetime$，报文最长生存时间，是报文在网络中存在的最长时间，超出则丢弃；类似于IP层中的`TTL`字段，`TTL`指IP数据报可以经过的路由器最大数量，每经过一个路由器即减一，为0则丢弃，所以`MSL`要大于`TTL`为0所耗的时长；一般`TTL`值为64，而Linux中`MSL`设置为30s，即认为经过64个路由器所用的时间最长不超过30s。

至于`2MSL`则是指一来一回所用的时间，如果客户端（主动关闭方）收到对端FIN报文，会重置`2MSL`，重新等待。同时`2MSL`也代表允许至多一次重传，因为连续两次报文丢失的概率很小。 	

如果修改`MSL`的默认值，需要修改内核并重新编译。



### 为什么需要TIME_WAIT状态

**只有主动关闭方才会有`TIME_WAIT`状态。**

* 防止（同四元组的）历史连接中的数据报造成扰乱

![TIME_WAIT REASON 1](.\图片\网络八股\TIME_WAIT REASON 1.png)

如果跳过`TIME_WAIT`状态/`TIME_WAIT`状态过短，而此时立即新建立同四元组的连接，那么如果上一次连接中阻塞在网络中的历史报文的序列号恰好在本次连接的窗口范围内（因为序列号回绕等原因），那么新连接将会错误的接收历史连接报文。

所以`TIME_WAIT`状态会等待`2MSL`时间，相当于等待一个网络来回，将所有可能到达的阻塞网络报文全部在本次连接中自然消失，而不会影响到下一次连接。

* 保证被动关闭的一方正确关闭

![TIME_WAIT REASON 2](.\图片\网络八股\TIME_WAIT REASON 2.png)

如果跳过`TIME_WAIT`状态/`TIME_WAIT`状态过短，导致主动关闭方直接`CLOSE`，此时主动关闭方的第四次挥手`ACK`又发生丢失，那么被动关闭方重发的第三次挥手`FIN`报文将会被主动方以`RST`报文回复，那么被动关闭方将会因异常终止。因`RST`而关闭不够优雅。



#### TIME_WAIT期间收到报文

在`TIME_WAIT`状态下收到`SYN`、`RST`及其他类型报文该如何处理：

* 收到`SYN`报文

首先检查是否合法：1）时间戳是否大于最后一个收到报文的时间戳；（开启时间戳前提下）2）序列号是否大于期望收到的下一个序列号；如果都大于则为合法，否则不合法；

（此时仅要求序列号大于，而不是刚好下一个期望序号；也就是说`TIME_WAIT`状态下收到的SYN不会遭遇challenge ack）

合法`SYN`：重新开始连接，`TIME_WAIT`转为`SYN_RECV`状态

不合法`SYN`：会回复之前的第四次挥手`ACK`，接收方将会因为序列号不匹配而回复`RST`报文

* 收到`RST`报文

Linux下，在`TIME_WAIT`时收到`RST`由内核参数`net.ipv4.tcp_rfc1337`决定，此参数分为0，1两种；

0 - 收到`RST`提前结束`TIME_WAIT`，释放连接；

1 - 丢弃`RST`；

* 收到其他类型报文 `TCP_TW_SUCCESS`

直接丢弃，不做响应



### TIME_WAIT 优化及为何出现大量TIME_WAIT

大量连接处于`TIME_WAIT`状态主要危害在于：

1）占用系统资源：内存、文件描述符、CPU、线程等

2） 占用端口资源（一般为`net.ipv4.ip_local_port_range = 32768 61000`）

假设客户端（主动断开方）向同一「目的 IP+ 目的 PORT 」的服务端建立连接，如果存在大量`TIME_WAIT`状态，导致端口被占满，那么无法建立新的向此服务端的连接，但是正在使用的端口可以继续连接；若向其他IP+Port连接，端口可以重复使用，因为内核中定位连接使用四元组，而非端口号定位。

#### 优化

1）打开 `net.ipv4.tcp_tw_reuse` 和 `net.ipv4.tcp_timestamps` 选项

`net.ipv4.tcp_tw_reuse`开启此参数后，内核会允许复用处于`TIME_WAIT`状态的连接，但只能用于客户端，因为开启此参数后，内核会在调用`connect()`函数时，随机找一个`TIME_WAIT`状态超过1s的连接给新的连接复用。

但是此功能需要开启时间戳后，才会生效。

**仅适用于需要调用`connect()`的客户端**



2）程序中使用`SO_LINGER`

《UNIX网络编程》书中对`SO_LINGER`描述为套接字的发送缓冲区内残留的待发送数据处理方式，以及```close()```返回的时机。

```c
struct linger so_linger;
so_linger.l_onoff = 1;
so_linger.l_linger = 0;
setsockopt(s, SOL_SOCKET, SO_LINGER, &so_linger,sizeof(so_linger));
```

如果设置为上述参数，则`close()`调用后会直接丢弃发送缓冲区数据，向对方发送`RST`报文，从而跳过`TIME_WAIT`状态，关闭连接。



3）`net.ipv4.tcp_max_tw_buckets`

这个值默认为 18000，**当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置**，这个方法比较暴力？？

Q：重置？哪种方式的重置？

应该是一旦`TIME_WAIT`状态的连接数量超出此值，后面关闭的连接将跳过`TIME_WAIT`状态而关闭。

4）扩大可用的端口数量

修改内核中的`net.ipv4.ip_local_port_range`参数，扩大可用端口数



以上措施很多都是基于跳过`TIME_WAIT`状态设置，但是恰如《UNIX网络编程》一书中却说道：**`TIME_WAIT` 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它**，所以不要盲目终止`TIME_WAIT`



#### SO_LINGER

```C++
struct so_linger
{
    int l_onoff;
    int l_linger;
};

setsockopt(s, SOL_SOCKET, SO_LINGER, &so_linger,sizeof(so_linger));
```


默认`close()`调用后，默认是引用计数减1，并立即返回，并发送发送缓存区中的数据，也就是说`close()`返回不代表已经接收到对端的`ACK`。

所以新增`l_linger`设置一个时延，此段时间内（没进入`CLOSE`状态）如果收到对端`ACK`，则`close()`正常返回，否则返回`EWOULDBLOCK`。

但是仍然存在问题：

收到对端发来的`ACK`，并不代表对端已经读取，只能说明对端的`TCP`协议栈收到了，但不一定`read()`，`read()`前服务端完全有可能崩溃；为解决这个问题只能在应用层发送自定义的`ACK`，然后客户端`read`到这个`ACK`后再`close()`。

```C++
#include <sys/socket.h>
int shutdown(int sockfd, int howto);

// howto:
// SHUT_RD(0)
// 关闭接收，丢弃接收缓存区数据，新的接收数据将直接丢弃
// SHUT_WR(1)
// 关闭发送，先将发送缓存区中数据全部发送，然后发送FIN（无视引用计数），此后不能调用写函数
// SHUT_RDWR(2)
// 等效于 调用两次shutdown()
```

 `close()`函数将会使引用计数减一，如果引用计数不为0，将不会发送FIN报文给对端；但是`shutdown()`函数将可以无视引用计数，直接发送FIN报文，从而触发连接关闭。同时`close()`函数将会关闭发送和接收方向的数据传送，但是`shutdown()`函数可以自行决定关闭的方向。

> 调用了 close 函数意味着完全断开连接，**完全断开不仅指无法传输数据，而且也不能发送数据。 此时，调用了 close 函数的一方的连接叫做「孤儿连接」，如果你用 netstat -p 命令，会发现连接对应的进程名为空。**


| 函数                                      | 意义                                       |
| --------------------------------------- | ---------------------------------------- |
| close() with l_onoff = 0 (default)      | 默认的处理方式；close调用后**立即返回**，套接字**不能发送或接收请求**：套接字发送缓存区的数据将会发送，如果套接字引用计数为0，则发送FIN，并抛弃接收缓存区内容 |
| close() with l_onoff = 1, l_linger = 0  | close调用后立即返回，套接字**不能发送或接收请求**：发送和接收缓存区的数据将会被抛弃，同时向对端发送`RST`，跳过TIME_WAIT直接进入CLOSE |
| close() with l_onoff = 1, l_linger != 0 | 套接字**不能发送或接收请求**：套接字发送缓存区的数据将会发送，如果套接字引用计数为0，则发送FIN，并抛弃接收缓存区内容；如果在连接变为CLOSE前延迟时间(l_linger)到，close将返回EWOULDBLOCK错误 |
| shutdown() with SHUT_RD                 | 套接字**不能接收请求**，仍可向套接字中发送数据，接收缓存区中数据丢弃，新收到数据丢弃（但会回复ACK，对端完全无法感知），对发送缓存区无影响 |
| shutdown() with SHUT_WR                 | 套接字**不能发送请求**，仍可从套接字中接收数据，将发送缓冲区中数据发送完毕后，发送`FIN`报文，对接收缓存区无影响（即所谓半关闭） |



### 开启tcp_tw_reuse可能的问题

当使用相同的四元组的连接发起时，如果原四元组在`TIME_WAIT`状态下并开启了`tcp_tw_reuse`，则不会显示端口已被使用，而是会检查`TIME_WAIT`下的旧连接是否超过1s，如果超过则复用此连接。此参数仅适用于主动关闭方。

开启`tcp_tw_reuse`的同时也需要开启时间戳选项才能生效，时间戳有效的防止了历史报文的干扰，以及序列号回绕问题。



1）历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。

![tcp_tw_reuse存在的问题1](.\图片\网络八股\tcp_tw_reuse存在的问题1.png)

但是内核在收到`RST`报文时会忽略其中的时间戳信息，或者说即使是过期的`RST`报文，也不会丢弃，而是接收。所以当某个RST报文因网络阻塞未能到达，此时旧的连接在TIME_WAIT阶段持续1s后，因`tcp_tw_reuse`被新的同四元组连接复用，这是RST报文才到达，将会导致新的连接断开。究其本质还是因为`tcp_tw_reuse`参数导致`TIME_WAIT`阶段过短，从而出现了历史报文。



2）如果第四次挥手的 ACK 报文丢失了，有可能被动关闭连接的一方不能被正常的关闭

![tcp_tw_reuse存在的问题2](F:\Markdown\研一上\图片\网络八股\tcp_tw_reuse存在的问题2.png)

如果主动关闭方启用`tcp_tw_reuse` 而复用连接前的第四次挥手ACK丢失，则面对重传的第三次挥手报文，新连接将会回复RST，从而关闭被动连接方。而如果被动连接方处于`LAST_ACK`状态下，收到新连接的SYN，此时被动方将会回复之前的序列号和期望序列号，即`challenge ack`，从而关闭新连接。



### 服务器出现大量 TIME_WAIT 状态的原因有哪些？

因为`TIME_WAIT`状态只有主动关闭方才会出现，所以服务器端出现大量TIME_WAIT说明服务器主动关闭了`TCP`连接。可能的原因有：

1）HTTP没有使用长连接

HTTP中如果设置keepalive参数，那么客户端和服务端之间的请求-响应将会在同一个`TCP`连接下完成，而不是每一个请求-响应使用单独的`TCP`连接。

如果客户端和服务端的任意一端没有设置keepalive（即不使用长连接），那么**都将由服务器端负责关闭连接**。

> 当客户端开启了 HTTP Keep-Alive，而服务端禁用了 HTTP Keep-Alive，这时服务端在发完 HTTP 响应后，服务端也会主动关闭连接。
>
> 为什么要这么设计呢？在服务端主动关闭连接的情况下，只要调用一次 close() 就可以释放连接，剩下的工作由内核 TCP 栈直接进行了处理，整个过程只有一次 syscall；如果是要求 客户端关闭，则服务端在写完最后一个 response 之后需要把这个 socket 放入 readable 队列，调用 select / epoll 去等待事件；然后调用一次 read() 才能知道连接已经被关闭，这其中是两次 syscall，多一次用户态程序被激活执行，而且 socket 保持时间也会更长。
>
> WHY？三次握手、四次挥手中TCP栈负责哪些东西的处理？？？哪些东西需要主动的系统调用！

2）HTTP长连接超时

未防止建立长连接之后，两端长期没有数据交互而造成连接资源浪费，像nginx会为每个长连接维护一个计时器，如果计时器时长内没有新的请求，那么触发回调函数，由服务器端主动关闭长连接。

排查时可以检查网络连接，是否因为网络故障导致客户端的请求未被接收。

3）HTTP长连接的请求数量达到上限

Web服务器中一般会为每个长连接设置可以执行的最多的请求数量，如nginx 的 keepalive_requests 这个参数（默认100），这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。**如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接**，那么此时服务端上就会出现 `TIME_WAIT` 状态的连接。



### 服务器出现大量 CLOSE_WAIT 状态的原因有哪些

`CLOSE_WAIT`是被动关闭方才会有的状态，此状态表示等待主动调用`close()`函数，如果一直没有调用，将会无法进入`LAST_ACK`状态。出现大量`CLOSE_WAIT`状态就说明服务端一直没有调用`close()`去关闭连接。

大概率是代码逻辑问题，如`listen()`的fd或者`accept()`到的fd等等没有注册到epoll或者select中，导致没有感知到对端的FIN报文，更或者干脆自己忘记调用`close()`了。



### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

此处的客户端故障特指主机侧的宕机或断电重启等故障，而非进程崩溃，也不是主机正常关机。

可以开启TCP中的`SO_KEEPALIVE`选项，同时Linux中可以修改内核参数以定制keepalive行为。

KeepAlive机制：如果客户端和服务端长期没有活动，TCP保活机制会每个一段时间，发送一个探测报文，连续几个探测报文没有响应则认为对端已经不可达，内核将通知给上级应用程序。KEEPALIVE只适合探测主机故障。

Linux内核参数：

```C++
net.ipv4.tcp_keepalive_time=7200 // 多久没有活动后发出探测报文，7200s
net.ipv4.tcp_keepalive_intvl=75  // 每个探测报文的间隔时长，75s
net.ipv4.tcp_keepalive_probes=9  // 累计多少个探测报文后认定对端不可达，9次
```

1）对端正常

发送探测报文后，对端会正常响应，保活时间会重置

2）对端已宕机

对端无响应，认定对端不可达

3）对端断电后已重启

对端此时可以响应，但是重启后原连接数据已经清空，所以回复`RST`。

推荐应用端自行实现心跳机制，更快感知对端故障。

### 没有 listen，能建立 TCP 连接吗？

答案：**可以的**。

客户端是可以自己连自己的形成连接（**TCP自连接**），也可以两个客户端同时向对方发出请求建立连接（**TCP同时打开**），这两个情况都有个共同点，就是**没有服务端参与，也就是没有 listen，就能 TCP 建立连接。**

但如果不是TCP自连接，没有`listen()`时，收到客户端发起的`SYN`报文后，服务端会直接回复`RST`报文。因为只有在系统调用`listen()`之后才会创建半连接和全连接队列，用于暂存连接信息，服务端没有对应连接信息，则符合`RST`发送条件。

而自连接之所以可以成功是因为，除了半连接和全连接队列之外，内核还存有全局的映射表，如全局的监听映射表，绑定表等，自连接/互相connect时，映射表中有对应连接信息，所以可以建立连接。

### 端口复用

#### UDP、TCP使用同一端口号

`UDP`和`TCP`使用同一个端口号，是因为在上交至传输层之前，`IP`层可以根据头部的「协议号」字段知晓对应协议，从而交给不同的传输层模块处理。

#### 服务端-TCP绑定bind同一端口

正常情况下，一个正在使用的IP+PORT连接，如果重复启动，后启动的连接在`bind()`时会报错“Address already in use”；

而更常见的情况是，关闭上一个连接，然后重启，如果上一个连接正处于`TIME_WAIT`状态，后启动的连接同样会报错“Address already in use”。

其他，如 TCP 服务进程 A 绑定的地址是 0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。因为0.0.0.0表示任意地址，包含192.168.1.100地址，和后续同端口的连接冲突。

为解决上述问题，可以在**`bind()`之前**，设置TCP的`SO_REUSEADDR` 属性，那么针对处于`TIME_WAIT`状态的连接，如果设置了`SO_REUSEADDR`，内核将会允许绑定成功，从而帮助更快的重启服务。

```C++
int on = 1;
setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
```

`SO_REUSEADDR`的另一个作用：

绑定的IP+PORT时，只要IP地址不是完全（**exactly**）匹配，就可以绑定成功。

如 TCP 服务进程 A 绑定的地址是 0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是192.168.1.100 地址（或者其他地址）和端口 8888，设置了`SO_REUSEADDR`属性，那么也会`bind()`成功。

> PS：不要使用SO_LINGER参数来实现快速重启服务，因为SO_LINGER是通过跳过TIME_WAIT状态来直接关闭连接，从而起到防止端口冲突，但《UNIX网络编程》一书中专门提到，TIME_WAIT不是坏事，不要试图跳过他。

#### 客户端-端口重复使用

通常使用`connect()`连接时，内核会随机选择一个有效端口号，作为源端口，而内核在定位一个连接时，通过四元组（源IP+PORT，目的IP+PORT）来定位，所以只要连接的四元组中任一值不同即视为不同连接，即允许端口重复使用。

当然，客户端也可以调用`bind()`绑定自己的源地址。

客户端如果出现大量`TIME_WAIT`状态，如果全部是与同一服务器（同目的IP+PORT）连接，那么当端口耗尽，就无法连接；但如果是与不同服务器连接，那么可以继续连接，短板取决于其他设备资源。

客户端大量`TIME_WAIT`状态可以设置内核参数`tcp_tw_reuse`，将那些`TIME_WAIT`状态超出1s的连接复用。

![](.\图片\网络八股\客户端发起连接.png)

#### SO_REUSEADDR、SO_REUSEPORT

`SO_REUSEADDR`

1）针对常见的多进程/多线程Web服务端，如果负责监听的进程崩溃，而其他已完成连接正常运行，此时重启监听进程，因为试图绑定的端口和已经存在的连接冲突，`bind()`会调用失败；所以需要`bind()`之前设置`SO_REUSEADDR`；当然针对`TIME_WAIT`状态，同样需要。

2）服务器绑定多个IP地址，但端口相同，这在托管着多个http服务器的站点很常见，如果服务器先绑定一个`INADDR_ANY`和端口4566，然后绑定其他的ip地址（如192.168.10.13）和端口4566，`bind()`会调用失败；所以需要`bind()`之前设置`SO_REUSEADDR`。即之前提到的绑定的IP+PORT时，只要IP地址不是完全（**exactly**）匹配，就可以绑定成功；

3）`SO_REUSEADDR`允许单个进程捆绑同⼀端口到多个套接字 上，只要每次捆绑指定不同的本地IP地址即可；

4）针对UDP而言，`SO_REUSEADDR`允许**完全重复的捆绑**（捆绑相同IP地址和相同端口号），但是TCP不允许；UDP主要是针对组播/多播而允许启动多个绑定同IP+PORT的副本。

所以建议每个服务端启动`SO_REUSEADDR`参数。



`SO_REUSEPORT`

1）本选项允许**完全重复的捆绑**，不过只有在想要捆绑同⼀IP地址 和端口的每个套接字都指定了本套接字选项才行；

2） 如果被捆绑的IP地址是⼀个多播地址，那么`SO_REUSEADDR`和 `SO_REUSEPORT`被认为是等效的









### TCP 重传、滑动窗口、流量控制、拥塞控制



### 全连接、半连接队列

全连接队列即accept队列，半连接队列即SYN队列

#### 全连接队列 （链表）

当全连接/半连接队列满后，收到的连接将会丢弃；全连接队列的最大长度为`min(backlog, /proc/sys/net/core/somaxconn)`，全连接队列的长度可以通过`ss`命令查看：

![全连接队列长度查看1](.\图片\网络八股\全连接队列长度查看1.png)

其中LISTEN状态时，Recv-Q表示当前全连接队列长度，Send-Q表示全连接队列最大长度，上图中为0和128；

![全连接队列长度查看2](.\图片\网络八股\全连接队列长度查看2.png)

但非LISTEN状态时，Recv-Q表示当前接收但未被应用处理的字节数，Send-Q表示已发送后未收到ACK的字节数，上图中为0和850字节



#### 半连接队列（哈希表）

Linux内核中设置了系统参数 `net.ipv4.tcp_max_syn_backlog`，但是半连接队列的最大长度不是仅由此参数定义，Linux2.6版本中，判定半连接队列是否超出使用三个参数同时判定，最大长度即为`min(min(somaxconn, backlog), tcp_max_syn_backlog) * 2 `，而Linux5.0.0版本中最大长度即为全连接队列的最大长度。

但不论哪个Linux版本，收到SYN后都需要三步检测

```C++
// 前提：未开启syn_cookies

if (半连接队列超出)
    drop;
if (全连接队列超出)
    drop;
if (tcp_max_syn_backlog - 当前半连接队列长度 < tcp_max_syn_backlog >> 2)
    drop;
```

也就是说，如果当前半连接队列未超出最大值，但是其长度大于 `tcp_max_syn_backlog  - tcp_max_syn_backlog >> 2`仍然会丢弃收到的SYN报文。



故Linux2.6版本中扩容半连接队列需要同时增大`tcp_max_syn_backlog, backlog, somaxconn`；

Linux中没有直接的命令查看半连接队列大小，但可以根据收到SYN后进入的`SYN_RECV`状态来推测半连接队列大小，`netstat -natp | grep SYN_RECV | wc -l`，同时通过仅发送SYN但不回复ACK（SYN攻击）来模拟半连接队列堆积。

![半连接队列长度查看](.\图片\网络八股\半连接队列长度查看.png)



PS：

如果连接的SYN发送到达时，全连接队列已经满了，那么SYN会被直接丢弃；（注意：**全连接队列满，也会丢弃SYN**）

如果SYN到达时，全连接和半连接队列都没满，那么进入半连接队列，此时如果全连接队列满了，新到达的ACK也将被丢弃，不过半连接队列中的仍然存在，后续如果全连接队列有空位，ACK又来了，可以继续完成连接。

### 传输优化

#### 三次握手期间的优化

客户端常作为主动连接发起方，服务端负责监听并给出回应

##### 客户端

默认五次重传，每次重传超时是上一次的2倍，并且5次结束后还会等待32s，还没有收到ACK才会结束三次握手。重传等均发生于传输层，应用层无法感知，所以可以调整重传次数，加快将错误暴露给应用层。

##### 服务端

1）优化主要为防止SYN攻击，可以使用提高半连接队列长度，开启`syncookies`，修改SYN+ACK重传次数（重传机制同上客户端）等措施。

2）当三次握手完成，连接建立后会放入全连接队列，如果全连接队列满，那么默认已经建立的连接将会丢弃，不过Linux中可以设置参数，修改全连接队列满之后的默认行为，如向对端发送RST复位报文，告知其连接失败。通常此参数设置为0，以应对突发流量。

```C++
echo 1 > /proc/sys/net/ipv4/tcp_abort_on_overflow  
// 参数设置为1，即全连接队列已满则发送RST，表示废弃
// 参数设置为0，即收到ACK后，检查全连接队列，如果已满则丢弃ACK
```

> 半连接队列正常，而全连接队列满，收到ACK会丢弃，而客户端发出ACK后已经进入`ESTABLISHED`状态，可以正常`write()`，服务端因为没有回应过，所以此时客户端发出的报文ACK仍和之前的相同，如果服务端全连接队列出现空位，服务端的连接状态也将恢复，从`SYN_RECV`进入`ESTABLISHED`。

##### 绕开三次握手

![TCP_FAST_OPEN](.\图片\网络八股\TCP_FAST_OPEN.png)

Linux3.7 内核版本之后，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建立的时延。使用此功能需要客户端和服务端双方同时开启。

首次连接和三次握手非常相似，新增了客户端发送的SYN报文的选项字段包含tcp fast open选项，且cookie值为空，服务端收到后生成对应的cookie值，并放置到SYN-ACK报文的选项字段中回应。

在之后的连接中，客户端发起连接，发出SYN报文（其中包含首次连接中生成的cookie值选项和数据部分，一般SYN中不包含数据），服务端会检验此cookie值是否有效，如果有效，会在发送的SYN-ACK中对cookie值和数据部分进行确认，如果无效，则只确认SYN报文对应的序列号。

如果服务端接受了数据部分，将可以直接做出回应，而无需等待SYN-ACK报文的ACK回应；如果服务端没有确认之前的数据部分，则客户端将会在第三次握手的ACK报文中附带重发数据部分，相当于正常的三次握手。

#### 四次挥手期间的优化

调用了 close 函数意味着完全断开连接，**完全断开不仅指无法传输数据，而且也不能发送数据。 此时，调用了 close 函数的一方的连接叫做「孤儿连接」，如果你用 netstat -p 命令，会发现连接对应的进程名为空。**

> 详见SO_LINGER处的解释

##### 主动关闭方

主要针对挥手报文的重传次数，`FIN_WAIT2`状态持续时间，`TIME_WAIT`状态的优化。

当进程调用了 `close` 函数关闭连接，此时连接就会是「孤儿orphans连接」，因为它无法再发送和接收数据。Linux 系统为了防止孤儿连接过多，导致系统资源长时间被占用，就提供了 `tcp_max_orphans` 参数。如果孤儿连接数量大于它，新增的孤儿连接将不再走四次挥手，而是直接发送 RST 复位报文强制关闭。

##### 被动关闭方

内核不限制`CLOSE_WAIT`状态的时长，所以如果出现大量连接处于`CLOSE_WAIT`状态应首先检查应用程序自身问题，是否在`read()` 返回0之后，忘记调用`close()`

其次为第三次挥手报文的重传次数优化

#### 传输数据的性能优化

TCP在连接建立时的SYN报文中会协商双方的窗口大小，书中提到的可以在`connect()/listen()`之前通过设置socket的`SO_RCVBUF`和`SO_SNDBUF`属性来修改接收和发送缓冲区大小。

不过《小林》中看到的是通过调节内核参数来实现接收和发送缓冲区大小变化，同时特别提醒**千万不要在 socket 上直接设置 SO_SNDBUF 或者 SO_RCVBUF，这样会关闭缓冲区的动态调整功能**；似乎更建议使用内核的自调整。

##### 窗口大小

TCP使用滑动窗口机制，TCP头部的窗口大小（16bit）字段即用来沟通接收方的内核缓冲区当前大小，从而控制发送速度，实现流量控制。但是16bit的字段代表最大的窗口值为2^16 Byte = 64KB，不适应当前的网络和数据实际，所以在可选的选项字段中新增窗口移位字段（14bit），从而使得窗口最大为2^30 Byte = 1GB。

Linux 中打开这一功能，需要把 `tcp_window_scaling` 配置设为 1（默认打开），要使用该选项需要在各自的SYN报文中发送该选项。

##### 发送缓冲区

首先明确一个概念：「带宽时延积」（缩写为 BDP，Bandwidth Delay Product） = RTT * 带宽，表示在途的TCP报文大小，如果超出此值，网络过载将易丢包，所以发送缓冲区不能设置过大，**由于发送缓冲区大小决定了发送窗口的上限，而发送窗口又决定了「已发送未确认」的飞行报文的上限。因此，发送缓冲区不能超过「带宽时延积」。**

发送缓冲区范围通过 `tcp_wmem` 参数配置，此参数包含「范围最小值， 初始默认值， 范围最大值」（单位字节），设定后由内核自行调节。

##### 接收缓冲区

接收缓冲区范围通过 `tcp_rmem` 参数配置，此参数包含「范围最小值（即使内存压力下）， 初始默认值， 范围最大值」（单位字节），设定后由内核根据当前内存使用情况自行调节。

发送缓冲区调节功能自动开启，而接收缓冲区自动调节需要配置 `tcp_moderate_rcvbuf` 为 1 来开启。



> 此上提到的缓冲区其实就是内核中的发送和接收缓冲区，不是用户态的。

##### 内存范围

接收缓冲区调节时，怎么知道当前内存是否紧张或充分呢？这是通过 `tcp_mem` 配置完成的，此参数包含「范围最小值（TCP使用内存小于此则不调节）， 第2个值（TCP使用内存位于第一和第二值之间，内核自动调节）， 范围最大值（TCP使用内存大于此则不再为TCP分配新内存，即新连接无法建立）」，其单位为页面大小，1页为4KB

### TCP -- 面向字节流协议

首先，UDP是面向报文的协议，因为其不要求可靠性，sendto时发送多少，一个报文中数据就是多少，放进网络协议栈发送，成功就收到全部，失败就是丢包。接收方会将UDP报文放入队列，每个元素就是一个报文。

而TCP因为发送窗口、拥塞控制等原因，send/write时发送的数据量，不能确保全部在一个报文中发出（此处不是TCP报文的分包，因为分包是放到了一个报文，只不过传输的时候切分，最后还是会合并的），如“Hello World”可能全部在一个报文，但也可能因为网络状况不佳或者当前发送窗口很小“He”作为一个报文发送出去，后半部分时窗口又变大了，所以也作为一个报文发送，此时接收方就会收到两个报文，它无从判断这两个报文是你send/write时所有数据，还是说前后到达的多个报文--即**粘包**问题出现。这是就需要应用程序自行协商如何区分报文。

最常见的是：

* 固定消息长度

所有消息固定长度，如64字节，接收方每次接受满64字节就认为是一个消息，然后组合在一起。

* 特殊字符做边界

Http中就是用回车加换行作为消息边界，用以分隔各个消息

* 自定义消息结构

一般会自定义一个消息结构，最常见的是报文首部写上后续内容长度，然后才是内容。接收方收到每一个报文后，先取出头部的如`sizeof(int)`检查消息长度，然后一直read直到满足此长度，组装为一个完整消息做后续处理。

```C++
struct
{
  int len;
  char* message_data;
}message;
```

**项目**

Paxos项目中大量使用了TCP，针对粘包问题，设计为发送时组装报文：

[引导头，长度（消息头部+内容），消息头部，实际内容，引导尾]

其中引导头和引导尾是固定格式、固定长度，接收方收到报文后，先放入缓存（自定义类，类ring buffer），然后不断遍历当前缓存，每次从中拿出一个完整的消息。其中消息头部中包含一些附带信息，如消息类型、内容长度、发送方id、接收方id、校验和等用于后续实际处理时的检查。

每次从中拿出一个完整的消息的具体步骤为根据引导头，在缓存中定位消息头部，并将除引导头尾之外的所有部分取出，如果缓存中数据长度能够满足从消息中取出的长度，那么缓存中指针恢复位置（相当于删除此部分），从而获取了

[长度，消息头部，实际内容]

而如果因网络原因获取的内容不全，则会继续read从而多次获取，直到满足完整消息为止。

可见实际项目的自定义消息体中会增加更多的定制信息，同时具体接收也会由此调整。



### TCP收到消息后的处理

前提：未关闭读，即shutdown with RD

因为滑动窗口的原因，只要在接收窗口范围内都会接收，而只有期望的下一个序号的报文才会递交上去，同时推动自身状态的变化（如收到**正序**的FIN之后才会修改自身状态为`TIME_WAIT`/`CLOSE_WAIT`）；所以当接受到乱序的报文，会先加入到乱序队列（红黑树结构），等再次收到正序的报文时，会先检查是否为FIN，然后在乱序队列中检查有无新的正序报文，如果有则处理，否则无视。

### 区分主机崩溃 / 进程崩溃

* 主机崩溃

指服务器突然宕机，所以内核也来不及做出任何反应；keepalive机制仅用于检测主机崩溃，无法应对进程崩溃。

* 进程崩溃

说明服务器仍然正常，此时内核会回收对应套接字资源，同时主动发出FIN挥手报文，并完成后续的挥手操作。

* 拔掉网线

首先物理层面的变动，不会影响内核中对应套接字等结构，所以在没有数据传输以及keepalive机制情况下，无感知，两端内核会认为连接仍然存在。有数据传输时，如果数据多次重传失败触发上限，连接会断开。

### TCP 延迟确认机制（ACK延滞算法）

因为单独的ACK报文中没有实际的数据信息，只有报文头所以网络传输效率并不高，而延迟确认表示接收方收到数据报文后不会马上发送确认，而是延迟一段时间，看此时段内有无响应数据报文发送，有则将ACK附带一起发送，如果延迟时间内没有数据报发送，则单独发送ACK。

因此机制默认开启，所以四次握手协议在抓包时常常只看到三次，第二次的ACK和第三次的FIN合为一个报文。延迟确认的最长和最短时间在Linux内核中设置。

如果要关闭 TCP 延迟确认机制，可以在 Socket 设置里启用 `TCP_QUICKACK`（只能在Linux 2.4.4+下运行），而可移植的方案是禁用Nagle算法，同时附带的禁用延迟确认。

> Nagle算法：尽可能减少小分组（小于MSS）报文的单独发送，具体为发送方收到上一个小分组报文的确认之后才会发送新的报文，以此将小分组报文合并发送。常与ACK延滞算法联合使用。
>
> 会造成小分组报文的响应延迟。

```C++
int value = 1;
// Linux 2.4.4++ 可用
setsockopt(socketfd, IPPROTO_TCP, TCP_QUICKACK, (char*)& value, sizeof(int));
// 可移植
setsockopt(socketfd, IPPROTO_TCP, TCP_NODELAY, (char*)& value, sizeof(int));
```

### 序列号变化

初始序列号由内核时间和哈希算法决定，而后续的序列号是每次**累加**本次发送的**数据字节数**，**SYN**、**FIN**报文虽然没有数据部分，但是视为**1字节的数据报文**，而**单独**的**ACK报文**视为**0字节**的数据报文。



### TIPS：

如何感知`FIN`报文：

服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 `EOF` 到**接收缓冲区**中，应用程序可以通过 `read` 调用来感知这个 FIN 包。这个 `EOF` 会被**放在已排队等候的其他已接收的数据之后**，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。

读到EOF后，read返回0



## IP

### ICMP协议

$Internet\ Control\ Management\ Protocol\ 互联网控制报文协议$，所以此协议的重心在于控制--根据网络中的报告调整传输策略，进而控制网络传输。其中报告有IP包是否可达、IP被废弃的原因等。

![ICMP](.\图片\网络八股\ICMP.png)

根据ICMP包头的类型字段，大致分为两类：

1）查询报文类型

有回送请求(Echo Request， 类型号 8)和回送响应(Echo Reply， 类型号 0)两类，ping即利用此类消息实现目的主机收到回送请求类型的IP报文后，会回复一个回送响应类型的IP报文。

2）差错报文类型

a）目标不可达 类型-3

Ⅰ）网络不可达 代码-0

没有IP地址中对应的网络号，所以发送一个ICMP报文给源主机

Ⅱ）主机不可达 代码-1

没有IP地址中对应的主机号，所以发送一个ICMP报文给源主机

Ⅲ）协议不可达 代码-2

对应IP地址限制此某协议报文，所以发送一个ICMP报文给源主机；如发送TCP给目的地址，但是目的地址禁止接收TCP报文（如防火墙），则发送一个ICMP报文给源主机

Ⅳ）端口不可达 代码-3

对应端口号未开启监听，所以发送一个ICMP报文给源主机（TCP中如果未监听，应该也会回复一个RST）

Ⅴ）需要分片但设置了不分片 代码-4

IP报文设置了不分片，但由于不同局域网下MTU不同，所以某些路由器要求分片，但是报文中设置了不可分片，则发送一个ICMP报文给源主机报告此情况，此报文会告知数据链路层的**MTU值**。

b）源点抑制 类型-4

当路由器中发送队列已满，无法发送时，发送一个ICMP告知源主机降低IP报文的发送间隔，减轻网络负载。但是因为这种 ICMP 可能会引起不公平的网络通信，一般不被使用

c）重定向 类型-5

当路由器发现源主机使用的不是最优路径发送数据，则发送ICMP告知源主机最优的路由信息，此ICMP中包含最优的路由信息和源数据

d）超时 类型-11

IP报文中的TTL（Time To Live）每经过一个路由器就会减1，当TTL降为0时该IP报文会被丢弃，此时路由器发送一个ICMP告知发送端主机，此报文已被丢弃。`traceroute`即使用此原理实现，每次发送的TTL从1递增，从而找到中间路径。

`traceroute/tracert`将IP包的TTL从1递增的同时发送**UDP**报文（不是直接发送IP报文）

> 以上很多的类型的ICMP类型报文都是在其他类型的报文发出去遇到问题之后，才会出现的，不是说发送ICMP报文出现ICMP。

### 127.0.0.1

127.0.0.1即为本地回环地址，对应Linux中的网卡`lo0`，当向127.0.0.1发送数据时，并不会经过真实网卡，如`eth0`等，也就是不会放入网卡可以映射到的RingBuffer内存区域，而是在网卡共享的`input_pkt_queue` 链表中，随后就被被软中断取出，再通过协议栈向上传递。



#### 127.0.0.1、localhost、0.0.0.0、本机IP

首先`localhost`不是IP地址，而是**域名**，只不过在hosts文件中，默认会把`localhost`解析为`127.0.0.1`；

`0.0.0.0`表示**本机所有的IPV4地址**，网络编程时的网络序`INADDR_ANY`就是`0.0.0.0`；

而网络序`INADDR_LOOPBACK`即为`127.0.0.1`，本地回环地址