一、程序中内存区分（非OS级别）：

1、静态内存：static变量（局部static、类static变量）和所有函数外的变量（全局变量）

作用域/生命周期： 为整个程序周期，static变量的生命周期开始于首次定义时



2、栈内存：函数内的非static变量

作用域/生命周期 ：仅在函数内或者说仅在其定义的作用域内



3、堆heap/自由空间free store：存储动态分配的对象--程序运行时分配的对象（new/malloc）

作用域/生命周期 ：由程序控制生存周期，必须显示释放；所以当某动态分配的对象离开其作用域（即无法再使用该对象），但其占用的内存空间并没有释放，即内存泄漏





PS：三种内存在内存中物理的存在形式或者组织形式？与程序编译链接时的只读段等关联？

常量或者文字常量，是否类似java也在堆上？



分配在静态内存和栈内存中的对象由编译器自动创建和释放，而分配在堆上的对象，由程序员决定其生存周期，只有显式的释放，对象才会被销毁。



类对象：如果使用构造函数实例化对象，如```Node a(3);```，其对象a存在于栈上，离开作用域，编译器自动析构；

而使用new operator，如```Node *a = new a(3);```，其对象存在于堆上，需要显式析构并释放内存 



二、增加面向对象特性后的C++内存实现原理 -- 《C++对象模型》书待看

虚函数，目前仅知道依照虚函数表的offset进行决议





三、初始化

首先明确，初始化 != 赋值

初始化是在变量创建过程中给赋予初值，而赋值是先（默认）初始化，再赋予新的值，相当于先把旧值擦除，再赋新值



五花八门的初始化一览：

```c++
//默认初始化
int a;
int *a = new int;
//值初始化
int a();
int *a = new int();
string name(3,'a');
//列表初始化
int a{};
//拷贝初始化
//类对象间用=时，其实调用的是拷贝构造函数
int a = 1;
```





1、默认初始化、值初始化

内置类型和类类型的默认初始化完全不同；值初始化较于默认，多了一对圆括号

内置类型使用默认初始化时，值是未定义的（全局变量除外，全局变量默认初始为0）；而值初始化时会赋予默认初值，如int默认赋0；

```C++
int a;//未定义  默认初始化
int a();//0  值初始化
```



类类型的默认初始化是默认使用默认构造函数去初始化；而值初始化如果未显式指定构造函数（即传入对应参数），则和默认初始化一致；类的值初始化取决于构造函数中对于数据成员的初始化，如果没有在构造函数的初始值列表中显式初始化数据成员，那么数据成员将在默认构造函数前执行默认初始化，所以数据成员是内置类型的，仍然是未定义的；

类中初始化的顺序：先构造函数的初始值列表，然后数据成员的默认初始化，最后构造函数的函数体（**函数体执行时说明初始化已经完成了**）；

所以你的数据成员是在构造函数函数体内‘’初始化‘’的，那么其实是先在外部默认初始化，然后进入函数体再赋新值；而const和引用类型不允许赋值，所以const和引用初始化的唯一途径就是在初始化列表中

>```C++
>class Cat
>{
>public:
>    int age;
>    string &name;
>};
>
>//推荐
>Cat(int a, string n):age(a), name(n){}
>//接受单实参的构造
>Cat(int a): age(a){}
>Cat(string &n): name(n){}
>
>//不推荐
>Cat(int a, string n)
>{
>    age = a;
>    name = n;//错误
>}
>```
>
>构造函数的初始值列表即为冒号后面的部分



类类型的默认和值初始化一样，可能也是因为如果用默认构造函数去显式的初始化，其实是一个函数的声明而不是对象

```C++
Cat bob();//声明了一个函数，而不是用默认构造函数初始化
Cat bob;//定义并默认初始化了Cat对象
```



2、数组的初始化

如果数组没有初始值列表，那么全部元素使用默认初始化；

如果数据有初始值列表，那么未定义的元素如果内置类型或者有合成的默认构造，则先使用零初始化；如果元素是类类型，再执行默认构造函数。

```C++
int arr[3];//内置类型做默认初始化；未定义，随机值
int arr[5] = {1, 2};//除前两外，其余都是0
int arr[5] = {};//全部是0
```



3、隐式初始化与隐式的类类型转化

```C++
Cat any = Cat(10);//显式的初始化：调用单形参的构造函数，虽然由等号，但没有调用拷贝构造
Cat any(10); // 隐式的初始化：隐式调用单形参的构造函数
```



针对只接受一个实参的构造函数，C++允许一步的隐式类型转换：**从构造函数参数类型到类类型的隐式转换**；所以建议对单参数构造函数```explicit```禁用隐式转换

```C++
Cat cindy = 10;//先从int转为Cat类型，然后拷贝构造，但实际编译测试时没有调拷贝构造，编译器优化了

Cat dom = "dooom";//错误，首先从char[]隐式转为string，然后从string隐式转为Cat，两次隐式转换，所以错误
Cat dom = string("dooom");//正确，显式的转为string，然后string隐式转为Cat
```



4、列表初始化

C++98中POD（plain old data，即没有构造、析构和虚函数的类或结构体）可以通过花括号，完成初始化，即列表初始化

```C++
int a[] = {1,2,3};
struct
{
    int data;
    int age;
}mystruct = {1,2};
```



C++11标准中列表初始化可用于其他类型对象的初始化，同时引入```std::initializer_list```,允许构造函数和其他函数像参数一样使用初始化列表

如果使用列表初始化，它会先去匹配initializer_list类型参数的构造函数；没有，会考虑用这些值调用其他构造函数（是这样吗？？？）





5、拷贝与赋值的区分

关键仍然在于初始化和赋值的区分，拷贝构造函数是初始化，重点在于新对象创建，而赋值是对已有对象的赋值，且仅限于类中的非static成员。

```C++
Cat a;//默认初始化
Cat b = a;//拷贝构造
/*------------------------*/
Cat b;//默认初始
b = a;//赋值操作符
```



**拷贝构造使用场景（除使用=定义变量外）：**

**1）函数调用时，参数为非引用类型**

**2）函数返回时，参数为非引用类型**

**3）用花括号列表初始化一个数组中的元素或一个聚合类中的成员**

```C++
Cat catArray[3] = {cat2, cat3};//列表初始化数组
//可以看到调用了两次拷贝构造进行初始化，而第三个元素由于未传入，所以使用默认构造
```

![image-20211218215538969](C:\Users\Zhong\AppData\Roaming\Typora\typora-user-images\image-20211218215538969.png)



四、值语义和对象语义

值语义value semantic

核心即为对象允许拷贝，且拷贝后的对象间脱离关系，C语言中全部都是值语义



对象/引用语义object semantic

对象不允许拷贝non-copyable；

多数的class都是对象语义，如线程，拷贝一个线程后，不能说又出现了一个一摸一样的线程；所以除少数值语义class外，**对象语义的class最好禁止拷贝构造函数和赋值运算符，防止无意中破坏程序行为**。





五、编程范式

数据抽象ADT abstract data type 、基于对象 object-baesd 、面向对象object-oriented



首先，数据聚合data aggregation即C语言中的struct，仅仅是数据的集合；

而ADT是在数据聚合data aggregation的基础上，实现了一系列操作，并隐藏了具体实现；C++的数据抽象不会带来性能损失，并会简化代码；**数据抽象是值语义的**，ADT class是可以拷贝的 

面向对象OO的三大特性即为封装、继承、多态；

基于对象则仅仅为封装，即只有具体类，没有抽象接口，和数据抽象很相似；

**但面向对象和基于对象均为对象语义**



新写一个class时，首先想清楚这个class是值语义的还是对象语义的，一般多数class是对象语义的。





六、public继承

public继承：is a

在写public继承时，应该认为public的继承是一种is a关系；即派生类是一个基类，所有的派生类都可以当作一个基类，基类的所有操作均适用于派生类，反之不行，派生类的操作不一定适用于基类；基类是更一般化，派生类是特殊化的基类