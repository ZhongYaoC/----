#### DLL / SO

##### Q：为什么使用动态链接？

程序开发过程中，不管是因为开发分工问题还是工程量问题，总会遇到用别人的代码。那么一种解决方法是把别人的代码copy过来，完全揉在自己的代码里面，这种太繁杂而且不好管理；另一种就是把别人的代码的目标文件组合成一个库，通过调用库中提供的函数或类完成自己的工作，后者即为链接，这种做法可以使库文件重复可用，减少管理成本。（其他优缺点?）

链接根据使用方式又分为两类，静态链接和动态链接，**静态链接**是把需要的目标代码从库文件（一个或多个目标文件的组合）**拷贝**到最终可执行文件中，此方式下，可执行文件中对外部符号及定义的链接发生在生成可执行文件时（注：拷贝到最终可执行文件中的只是那些需要的函数代码），执行程序时，不再需要从库中调用目标代码。而**动态链接**，在链接时只是在最终可执行文件中记录下共享对象的名字及其他信息，执行时，**动态链接库的全部内容**将映射到运行对应进程的虚地址空间（注：此处之前有理解错误，认为静态会把所有函数拷贝过去，而动态只运行时映射所需函数，完全反了）。

（静动态链接优缺点）

（理解完全错误）~~静态链接不管函数是否需要调用都会拷贝进去，导致最后生成的应用程序执行文件偏大，占用较大内存；而动态链接是在需要时，才调用函数，并且可以被多个应用软件同时调用，进一步减少了占用内存大小。~~

静态链接（1）由于会将所需函数单独拷贝到可执行文件中，那么对于每一个调用了这些函数的程序，都会有这些代码的拷贝，重复的代码消耗磁盘空间；（2）运行时各进程会单独在自己的地址空间装入这些函数代码，多个进程调用同一函数时内存出现多份重复拷贝，占用内存空间；（3）由于对符号的引用是在链接时完成，所以当库文件中函数发生变化，需要重新链接到使用库的应用程序；归根结底，不是静态库本身链接拷贝进去的过大，而是在于没有共享性，从而冗余导致占用过大内存。

> 静态库会对语法做检查？和头文件中比对；而动态库只是简单的合到一起

动态链接又分为两类，隐式的动态链接和显式的动态链接，两者区别在于后者是调用（系统？）SDK拿到对应dll，然后再对应使用的代码段中获取该dll中需要的函数，传入参数，执行完后卸载相应dll；前者需要dll和使用dll的程序间需要一个dll文件中.lib的静态链接。隐式稍后细讲，dll文件本身稍后细讲。

```c++
/*使用dll的应用程序，显式的动态链接使用
* WIN32环境
* 此处预设已有dll文件，具体dll实现会在后文隐式的动态链接处展示
*/

//dll中对应的输出函数包含文件，需要提前设置好包含文件路径
#include "dllout.h"

int main()
{
    //函数指针？对应dll中该输出函数的声明
    typedef int (*Hello)(int);
    HMODULE HMod = LoadLibrary("test1.dll");
    
    if (DLL != NULL)
    {
        //获取dll中EXPORTFUNCTION函数，转为
        Hello hello = (Hello)GetProcAddress(HMod, "EXPORTFUNCTION");
        std::cout << hello(100) << std::endl;
        FreeLibrary(HMod);
    }else
    {
        std::cout << "dll调用失败" << std::endl;
    }
}
```

隐式、显式优缺点：

隐式更易实现；显示可以提前判断出错，如dll未加载等，但显示不一定适用于所有dll文件?



##### Q：dll文件要素

.h 包含文件，说明了所有对外提供调用的输出函数/类等；

.lib 依赖库文件，（隐式中）需要与使用dll的应用程序之间完成静态链接，以说明输出函数的位置，类似一个指向各输出函数的指针

.dll 可执行文件，真正运行的可执行文件集合体



##### Q：dll输出函数/类

（目前为止，该内容仅适用于WIN32，毕竟Linux下的动态链接库连名字都不一样，叫.so）

输出函数即要实际对外提供调用的函数，所以相比于普通函数，要声明对外提供服务；

可以把类和类内成员函数输出，也可以通过一个**输出函数将本库中类的指针输出**，从而实现使用外部应用程序的资源构筑对象。

```c++
//dllout.h
#ifdef WIN32
#define DLL_API __declspec(dllexport)
#else
#define DLL_API __declspec(dllimport)
#endif

class DLL_API DllClass
{
public:
      DllClass();
      ~DllClass();
      int DLL_API EXPORTFUNCTION(int)；
}

//dllout.cpp(可以在主cpp中，也可以另建一个cpp)
#include "dllout.h"

int DLL_API DllClass::EXPORTFUNCTION(int n)
{
    return n;
}
```



C++中还需要对.def文件中做修改（@后的nums，根据数量顺延），不过老师说现在不需要def文件也可以，VS2008环境下测试不行，VS2017测试可以

```C++
EXPORTS
    EXPORTSFUNCTION @2
```



#####Q：隐式动态链接的使用dll

思考一下，你现在的dll中已经有了输出函数/类，只要把dll文件编译、链接下就可以生成.lib，.dll，那么应用程序中怎么使用呢，考虑dll项目文件中的那些不同之处？



首先考虑.h包含文件，直接#include ” “ ，必然报错，所以要设置好程序的include路径或者#include中使用路径；之后直接调用输出函数/类就可以

其次，考虑.lib依赖库文件，和应用程序做静态链接，此处有三种方式

>1. 静态链接本质就是把目标代码拷贝过来，所以直接.lib拷到应用程序即可
>2. ide中项目属性，linker中设置（VS2008为项目属性-> 链接器中设置附加库路径和附加文件xxx.lib）
>3. .cpp中使用```#pragmacomment(lib, "xxx.lib")```，和调用它的源文件放在同一目录 或者 在引号里写完整路径

然后，考虑怎么使用.dll可执行文件，应用程序可以使用到该.dll文件即可，那么只要应用程序本身和dll程序的输出文件路径是同一路径就满足，ide中修改dll项目程序的输出路径为应用程序的输出路径即可

ps：项目联调时需要在vs中设置好项目间依赖关系，从而决定生成顺序



##### Q：嵌套的DLL

联调，dll b调用dll a，然后实际应用程序调用dll b，查看使用同名函数时的调用方式！！

如果dll b中使用与dll a中相同的函数名，会导致无法解析的重载。考虑如下，由于a b两个dll中都使用了extern “C”，所以编译器中符号名出现了重名。不过，调整了a、b中参数类型也无法解决？？？。

> 在实际编译过程中，函数名在对象文件中表现为符号名；而C++引入了函数重载，为防止编译器中出现函数重名导致无法明确使用哪个函数，所以编译器会采用一定的规则将函数名修改变成对应的符号名，但该规则不统一，不同编译器采用不同的修改规则；
>
> 当动态调用时，程序可能会调用别人的dll包，而这个包编译时与该应用程序所用编译器可能不同，调用函数时找不到对应位置，从而调用失败。而extern “C” 即表示以下函数在编译时不修改符号名，符号名即函数名



##### Q：unix环境下的动态链接库

g++/gcc命令的熟悉：

先在cpp文件当前路径搜索头文件，再从I指定目录下搜索最后系统include路径/usr/include下；o指定输出文件的名称

```g++ -o exec hello.cpp -I ~/include```



只编译、汇编为目标文件，不进行链接；同样```-S```只编译，不汇编，```-E```只做预编译

```g++ -c -o hello.o hello.cpp```



一步生成动态库文件，库文件名约定使用lib前缀，.so（动态）.a（静态）后缀

```g++ -shared -o ~/lib/libtest.so hellofun.cpp -fPIC```

调用动态库（-l 提示编译器调用哪个库文件）

```g++ -o exec hello.cpp -L ~/lib -ltest```

不过直接使用-L，执行时出现无法打开so文件的错误，在直接修改环境变量````LD_LIBRARY_PATH```后再带上-L成功(或者直接使用so所在绝对路径 ```g++ -o exec hello.cpp ~/lib/libtest.so ```)。感觉有问题。。



静态库的生成需要依赖shell工具```ar```，首先得到目标文件，再使用ar

```g++ -c -o hellofun.o hellofun.cpp```

```ar -r ~/lib/libtest.a hellofun.o```

调用静态库(g++默认先调用动态库，找不到才会调用静态库)

```g++ -L ~/lib -o execStatic hello.cpp -ltest```



装载库搜索顺序：先搜索LD_LIBRARY_PATH中分号前路径，接着-L指定目录，再LD_LIBRARY_PATH中分号后路径，最后搜索系统lib库路径/usr/lib



如果程序同时调用动静态库，可以使用-Bx参数，一般Bstatic、Bdynamic交替使用，前者使链接程序不使用其后-l参数指定的动态库，Bdynamic则是取消此设定

```g++ -o exec hello.cpp -L ~/lib -Bstatic -la -Bdynamic```



> 关联知识点：
>
> linux bash下环境变量的查看，修改、删除：
>
> 

