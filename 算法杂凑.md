贪心算法

局部最优从而求得全局最优

区间问题，按照区间开头或者结尾排序，有时候很重要；

想想问题之间转化，能不能转为同类型问题或者

数组需不需要提前处理下，统计一下信息：频率、第一次出现位置、最后一次出现位置、个数等



dp的本质是**穷举**所有状态，然后选择最优解；之后再做记忆数组之类的优化；

【选择】【状态】搞清楚



BFS题：

n叉树的层序遍历，

现在看来，不论是多叉树还是简单的二叉树，层序遍历就是BFS广度优先遍历算法，二者都利用队列来实现，以前居然没有关联起来过。

n叉树层序遍历这道题中，因为对输出结果的要求是每一层的节点区分开，所以除了BFS，重点就在于怎么区分某一层，在原有BFS的基础上内部再加一个外层的for循环，遍历完一层后，此时队列中刚好是下一层的节点。



删除有序数组的重复项，

不要总想着真正的删除元素，用不重复的元素将重复元素的位置覆盖即可；另外也说明了**有的时候排序是很好用的**，此题中有序后去重更易处理了

双指针：一个指针变动，另一个指针不动；或者说一个指针快，一个指针慢，快慢指针；数组类算法中常见



环



反转全部，反转部分



空间换时间，如果没办法就考虑这种，不要总想着原地完成，先写出一个解决方案再说！！





位运算需要汇总各类的，暂时遇到最多的是异或，





无论是dp还是其他算法，都会遇到自己创建一个一维或者二维数组，然后**赋予新的意义**，如`nums[i][j]`表示为第`i`行有没有`j`这个数字或者`j`表示某些状态，第`i`天在`j`这个状态下收益值





非常常见的位运算（paxos、文件操作权限等中也常见）：使用`|`表示赋予某值\权限，使用`&`检查是否拥有某值或某权限







辗转相除法  求最大公约数

```c++
int gcc(int a, int b)
{
  if (a < b)
  {
    swap(a,b);
  }
  
  while (b != 0)
  {
    int tmp = b;
    b = a%b;
    a = tmp;
  }
  return a;
}
```



整数求每个位的值（无论正、负）

```C++
while (x != 0)
{
  //个位数
  int t = x % 10;
  //把求所有位数都转为求个位数
  x /= 10;
}
```

**整数反转也好，字符串转整数也罢，转出来的值会不会超出int的取值范围很重要**！！`INT_MAX`，`INT_MIN`

>  [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)



回文三种做法：

1）双指针，一前一后

2）栈，先push进去，pop出来后是否相同

3）reverse后是否相同



反转问题，通常可以将局部反转和全局反转相结合来完成！



链表中一次找到中间位置的做法：

两个指针，一个一次走一步，一个一次走两步；这样走的慢的指针就在中间位置（如果偶数，则为靠左的中间）

> 此法与之后提到的Floyd判圈算法思路相同



KMP算法：

模式串、前缀、后缀、partial match table、next数组

最后其实是next数组的构造！（这地方还是有疑问）





最长公共前缀：

一般想到的是所谓”横向扫描“，即每个字符串之间比较，前两个字符串比较后的前缀，再去和后面的字符串比较求前缀，最终的前缀即为公共最长前缀；这也符合以往编程直觉：即先for循环字符串数组，再对其中的每个字符串处理；但是这样只能两个两个字符串的比较，

所以转换下思维，直接每列之间比较，即先for循环某一个字符串，相当于找到了要比较的列字符，然后循环字符串数组；这样就相当于一次性所有的字符串之间同时比较某一个字符

题解中提到的分治法，和归并排序真的很像，分分分， 最后变成两两字符串比较

二分法，思路也很巧妙，根据结果的长度范围来不断缩小



二分查找中发现的问题：

二分查找时，求mid到底是相加除二还是右减左侧除二 + 左侧，还是有问题；另外left和right如果移动时的边界问题一直存在！！

利用ACWing模板，可以简单的完成二分法，但是也发现在写浮点数二分法的check函数的时候，等于号的情况必须被谨慎考虑，如`if (nums[mid] <= target)`，还是只写`nums[mid] < target`，把等于号情况扔给else处理，这两种写法在最后`return left` 和 `return right`是不同的，因为浮点数二分跳出while循环的条件并不是left和right相等，浮点数运算下两者不能保证完全相等！！







链表类问题：

常见技巧为，**新增一个dummy节点，让它的next指向链表的头节点，用来当作虚拟头节点**，可以避免一大堆的删除头节点操作错误！！不用对头节点做特殊判断了（其实就是以前数据结构中学到的有头节点的链表）

> 「是否需要释放被删除节点对应的空间」这一问题，我们需要和面试官进行积极的沟通以达成一致
>
> 面试中沟通最重要，因为一个成熟的项目进行中，同事之间的沟通很重要，搞清楚各自在写什么，需求是什么，所以面试中会考察这方面；不要害怕问的问题太stupid，就不敢问！！

链表问题中，删除节点、插入节点时常常需要其**前驱节点**，新增dummy也方便找前驱prev

倒数第几个这种问题上，要么数学变换成正着数第几个，要么双指针，要么栈！（倒数问题上栈总是可以信任！）





「Floyd 判圈算法」（又称龟兔赛跑算法）

快慢两个指针，一个一次走两步，一个一次走一步，如果前方存在环，那么快指针将会首先进入环中，然后与慢指针在某个节点相遇（可能是套了几圈之后），如果没有环，那么快指针将会提前到达尾部nullptr





树 、 二叉树类题目：

树其实就是简化版的图，所以图的DFS、BFS都可对应的应用到树上

非递归写法：深度优先借助栈，广度优先借助队列；两者写起来其实几乎是一样的，只不过在图里面用DFS需要标记有没有访问过这个节点





BST树的各节点不能有相等的，要遵循严格大于或小于，否则达不到排序的效果







动态规划类题目：

搞清楚设定的dp数组的元素含义



#### 哈希表类：

首先，老生常谈：C++中的hash表分两类实现，一种是红黑树实现的set（+multiset）、map（+multimap），特点是会按照key排序，是有序的，因为红黑树本质就是平衡的二叉搜索树，查询效率和增删效率均为O(lgn)；

另一类是后来加入std的，unordered_set、unordered_map，底层使用hash table实现，查询效率和增删效率均为O(1)，特点是无序的，这类更像是以往常规想法中的哈希。

这两类共同的特点就是插入后，key值不能更改，只能删除再插入



空间换时间策略的大师

查询元素第一次出现的位置时，常常使用hash



不要无脑map/set，该使用unordered_map就是用unordered_map，因为后者的查询效率更高，只要题目不要求有序，就可以用；另外数组也可以作为快速的hash table



#### 位运算类：

求某个无符号数n的二进制写法中1的个数，用`1 << i`来让1不断提升，然后与n做与运算，则只有当n的这一位也是1时，与运算为true



| name   | function       | usage                                  |
| ------ | -------------- | -------------------------------------- |
| 异或 ^   | 相同为0，不同为1      | 两个数相等，则异或结果为0，0和数b异或结果为b<br />且异或遵守交换律 |
| 逻辑与 &  | 都是1为1，其余为0     |                                        |
| 逻辑或 \| | 只要有一个1即为1，其余为0 |                                        |
|        |                |                                        |
|        |                |                                        |

`__builtin_popcount`：内置函数求二进制中1的个数



Brian Kernighan算法：`n`与`n-1`做逻辑与运算，会把n的最低位的1置为0，所以逻辑与的结果和结果-1，继续做逻辑与运算，运算的次数即为1的个数



* 求n的第k位：首先，将n的第k位移到个位，接着和1做逻辑与；`n >> k & 1`

* lowbit(x)：返回x的最后一位1（x二进制从左往右的最后一个1及余下的0组成的数）；如1010000，lowbit后为10000

  应用：求x中1的个数，x -= lowbit(x)，减到0为止所用次数即为1个数

  lowbit实际为 `x & (-x)`即 `x & (~x + 1)`

#### 离散化

离散化适用情况是：在一个很大范围的数内，有效的（或需要拿出使用的）数的数量较少，如果直接对整个数做操作，如前缀和等，占用空间过大，耗时较久，所以将其中有效的部分提取出来，离散化为另一个值（如映射为数组索引，有些类似hash映射，模板中用二分查找作为离散函数），然后对离散化后的值做操作

题目：区间和



##### 区间合并

预处理基本是排序，按照区间的左端点排序或者右端点排序或者做右端点双关键字排序

区间是否重合判定条件：

先排序；

然后后一个区间的起点start 是否 小于等于（有没有等于取决于题意）前一个区间的终点end





##### 质数问题：（感觉考的概率很小，记录下）

暴力查找是O(n^2)，很慢

改进版的暴力查找，如：查找y是否为质数，x是其中一个因数，则y/x必然也是一个因数，而在x和y/x中选择一个较小的，范围必然在[2, sqrt(y)]，所以检索y的开方即可

埃氏筛：如果x是质数，那么2x，3x...肯定不是质数，根据此规律可求质数；而实际上不需要从2x开始判定不是质数，从`x*x`开始即可，因为 2x,3x,… 这些数一定在 `x*x` 之前就被其他数的倍数标记过了，为防止重复标记“不是质数”，直接从`x*x`即可

线性筛：埃氏筛在标记合数时仍然存在冗余，如45会被3和5都标记，所以引入线性筛，标记不在仅当x是质数时，而是针对所有整数，同时维持一个质数集合primes，每个整数与质数集合中的质数的乘积均标记为合数，同时为防止重复标记，当当前的整数i与某个质数primes[j]求余为0时停止标记（i可被primes[j]整除）。因为下一个即将被标记的数`i*primes[j+1]`必然在之后的某个i时被标记！因为`i*primes[j+1]；会在之后的整数等于i/primes[j] * primes[j+1]的时候被标记，而且是在乘以primes[j]时就标记`，从而防止了重复标记



#### 数组类

1、数组题目中双指针总是很值得尝试的方法

> 第一次会，第二次不会了！！需加强
>  [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)
>
>  [27. 移除元素](https://leetcode.cn/problems/remove-element/)

若为两个同向指针，通过某些条件，让其中一个指针走慢（满足条件才会++），所以关键在于找出那个条件来；

当然也有对向的双指针，还有位于不同序列的指针，如归并排序

滑动窗口也属于双指针，不过区别在于滑动窗口的起点也会随情况调整

2、二分查找的各种用法（二分要求有序，且可随机访问，所以属于数组类）

3、有时先排序也不失为好法子

4、其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作（包含字符数组等）



#### 单调队列 & 单调栈

单调队列中需要保持队列的递增或者递减原则

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)此题的题解中可涉及单调队列或者优先队列；优先队列中使用了延迟删除的思路，单调队列法更像是告诉你如何使用`deque`构建一个合适的单调队列，值得学习，并且不同问题下的单调队列构建是不一样的；方法三使用了分组加预处理的手法，此类做法在之前某题中遇到过。。组内的好解决，然后跨组的，需要考虑好衔接问题

单调队列最常见题型：求滑动窗口的最大值、最小值

```C++
// 模板 -- 数组为n个，窗口为k个元素，求每个窗口最小值
// 暴力解法：先遍历数组，然后对其前面的k个元素遍历求最值，复杂度为O(nk)
// 单调队列：暴力的内循环类似于k个元素组成的队列
// 而对于此队列来讲，队列尾部的值如果是小于队列中其他元素的，那么队列中其他元素不可能出现在结果中，
// 即只要有这个元素在，队列中其他元素就不可能出头，可以从队列中去除；所以整个队列将会保持单调递增的特性
// 队列中保存有下标，只需要每次都检查下标是否超出即可
//（不可以使用队列size是否等于k来判定，因为队列中有可能只有一个元素，只要下标正确就可以）
vector<int> arrays();

deque<int> que;//使用双端队列，存储下标
for (int i = 0; i < n; ++i)
{
  // 窗口元素不能超出k，而每次只会前进一步，所以if即可，不需要while
  if(!que.empty() && i-k+1 > que.front())
  {
    que.pop_front();
  }
  // 如果要加入队列的值更小，则当前值更适合作为窗口的最小值
  while (!que.empty() && arrays[i] <= arrays[que.back()])
  {
    que.pop_back();
  }
  // 当前值入队，此时的队列已经是个单调递增队列
  que.push_back(i);
  
  if (i >= k-1)
  {
    //根据队列递增特性，最小值为队头
    printf("%d ", que.front());
  }
}
```







单调栈最多的题型为：左边/右边离它最近的比他大/小的数

```C++
// 模板 -- 求数组中每个左边第一个比它小的值
// 暴力解法:先遍历数组，然后对每个元素i，遍历其左边i-1到0的元素
// 单调栈：暴力中的内循环相当于把i左边的所有元素放入栈中，然后比较
// -- 由于每个元素最多插入一次，弹出一次所以单调栈的复杂度为2n,即O(n)
// 而如果a_x >= a_y, x < y （即x在y左边）
// 就说明对于a_y来讲，a_x必然不是其结果，而对于比a_y右边的数来讲，a_y是比a_x更好的结果-更靠近且更小
// 所以a_y是不可能出现在结果中的，直接出栈
// 所以栈内元素将会是单调递增的，也就是所谓单调栈

vector<int> arrays();//假设n个元素
stack<int> st;
for (int i = 0; i < n; ++i)
{
  while (!st.empty() && st.top() >= arrays[i])
  {
    st.pop();
  }
  if (!st.empty())// 如果栈不空，则栈顶必然i的结果
  {
    printf("%d ", st.top());
  }
  else// 说明没有比它更小的左侧值
  {
    printf("-1 ");
  }
  
  // 不要忘记每个值都要入栈
  st.push(arrays[i]);
}
```









#### 树（二叉树）

写树的递归函数时，如果需要遍历整棵树，递归函数就不能有返回值。如果需要遍历某一条固定路线，递归函数就一定要有返回值！

仍有疑问，为何？

之前求所有左叶子节点和时，遍历了全树，但递归有明确返回值？

- 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
- 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在[236. 二叉树的最近公共祖先 (opens new window)](https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html)中介绍）
- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况 [112. 路径总和](https://leetcode.cn/problems/path-sum/)）


搜索一条边的写法：

```c++
if (递归函数(root->left)) return ;

if (递归函数(root->right)) return ;

```

搜索整个树写法：

```c++
left = 递归函数(root->left);
right = 递归函数(root->right);
left与right的逻辑处理;
```



用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销。







二叉树--自底向上的遍历，第一反应就是后序遍历（即回溯）；

在二叉树中通过两个前后指针cur、prev作比较，会经常用到；

* 二叉树的最近公共祖先，一般二叉树使用后序遍历，自底向上的搜索全树；而二叉搜索树因为是有序的，公共祖先必然在你要查找的两个节点中间，所以无需后序遍历，根据当前节点的数值特点向左子树遍历或者向右子树遍历即可。
* 求中点值时通常写法为：`int mid = (left + right) / 2;`但是如果left和right都很大，就有可能导致int越界，所以如果有越界风险，应该写为`int mid = left + (right - left) / 2;`




#### 回溯法

回溯是递归的副产物，只要有递归就有回溯；回溯法也经常和二叉树遍历，深度优先搜索混在一起，因为这两种方式都是用了递归。（PS：或者是回溯其实就是深度遍历）

回溯的本质就是穷举、**暴力搜索**，最多加上一些剪枝优化；常用于解决组合、分割、子集、排列、棋盘类问题

回溯问题都可以抽象为树形结构（N叉树）

```C++
//模板；基本思路为在树结构中一层一层向下走，每做出新的选择，剩余可选要更新；走完要回退
//参数在代码编写中缺啥补啥
void BackTrack(参数)
{
  if (终止条件)
  {
      //保存结果 -- 如；以树的路径为记忆模板
      return;
  }
   for (选择，本层集合中的元素)
   {
     //处理当前选择
     BackTrack(路径， 上部选择后剩余的可选元素集合);
     //回溯，撤销处理结果
   }
}

//树求全部路径或者符合总和的某条路径问题，就是回溯，只不过没有显式的使用for循环遍历集合中的所有
//因为对于某个树节点，它的选择即为左孩子或者右孩子
```

回溯的优化往往是进行一些剪枝操作，**剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了**。



例题：

1、[40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

题目要求：`candidates` 中的每个数字在每个组合中只能使用 **一次** 。解集不能包含重复的组合。 

所以要关注去重，要区分同一条路径上重复元素是允许的，但是同一层上重复元素不可以，因为排序后，如果同一层有重复元素，那么之后的组合必然重复，两者会做出完全相同的选择

![回溯-组合2](..\研一上\图片\算法\回溯-组合2.png)

```C++
class Solution {
public:
  	// 常常利用index来判定选取开始点或者切分点！！
    void BackTrack(vector<int>& candidates, int rest_target, int start_index, 
                vector<int>& cur_comb, vector<vector<int>>& res)
    {
        if (rest_target == 0)
        {
            res.push_back(cur_comb);
            return;
        }

        for (int i = start_index; i < candidates.size() && rest_target >= candidates[i]; ++i)
        {
            // 同一层相同值和某条路径上有相同值的区别
            // 以最顶层来看，是这一层的i++后需要判定的，此时的i必然大于start_index
            // 而某条路径是递归进入后的，即i == start_index
            if (i > start_index && candidates[i] == candidates[i-1]) 
              //判断条件前后顺序不能变，否则会出现i-1 == -1，数组越界
            {
                continue;
            }
            cur_comb.push_back(candidates[i]);
            BackTrack(candidates, rest_target-candidates[i], i+1, cur_comb, res);
            cur_comb.pop_back();
        }
    }

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) 
    {
        vector<vector<int>> res;
        vector<int> cur_comb;

        // 排序是必须的，否则无法根据同树层不可相同来判定重复
        sort(candidates.begin(), candidates.end());
        BackTrack(candidates, target, 0, cur_comb, res);
        return res;
    }
};


// 此题也可以使用set去掉同树层的重复，维持一个同层遍历时的set即可
// 但是无论如何，事先的排序是必须的
unordered_set<int> uset;
for (int i = start_index; i < candidates.size(); ++i)
{
  	if (uset.find(nums[i]) != uset.end())
    {
      continue;
    }
  	uset.insert(candidates[i]);
  	cur_comb.push_back(candidates[i]);
  	BackTrack(candidates, rest_target-candidates[i], i+1, cur_comb, res);
  	cur_comb.pop_back();
}
```



**子集和组合问题之间的区别**

如果将回溯转化为树结构，那么**组合和分割问题所求是叶子节点的值，而子集问题求的是树中所有节点的值**，所以子集问题可以没有结束条件，因为组合问题中结束条件通常用来判定是否到达叶子节点，然后返回“路径”，而子集问题中所有节点都需要。

![回溯-组合1](.\图片\算法\回溯-组合1.png)

![回溯-子集1](.\图片\算法\回溯-子集1.png)



子集和组合问题经常会用到`start_index`来标记当前的“分割点”，之后的选择中从分割点之后选，但是排列中不需要，因为排序每次都是从最初始位置开始选择



#### 贪心算法

老生常谈，贪心的策略就是每一步都选择最优，进而在全局达到最优；可惜不是所有问题都是局部优则全局优，可能需要动态规划，所以选择贪心之前需要分析题意。而且有些题目看着不是贪心，就得用贪心，，如之前做的射气球等问题。

**贪心没有固定套路，刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心**。

贪心关键就在于分解出子问题，然后子问题的贪心策略，最后子问题最优解堆叠出全局最优；抽象到爆，只能说用来当作总思路。



如果题目中**涉及两个维度都需要考虑（如相邻中左和右；身高和体重），那么思路应该是先固定其中一个维度，然后处理另一个维度**，两边同时考虑会顾此失彼 [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)   [135. 分发糖果](https://leetcode.cn/problems/candy/)



**区间重合问题**中，经常使用到的技巧：按照区间的起点或者终点排序，但是排完序之后如何遍历又不同



#### 动态规划

动态规划的状态一定是从上一个状态推导出来的，（回溯法中也涉及选择、状态，区别？）

1、确定dp[i]的含义和**下标i本身**的含义

2、确定递推公式（先）

3、dp的初始化（后）

4、确定遍历顺序 ？ （从前往后，还是从后往前）

5、举例推导dp数组，相当于预先推导，然后debug的时候比较自己推导和计算出的dp之间的区别





**动规问题时间复杂度 = 状态数量 * 转移所用计算量**

##### 背包问题

###### 0-1背包问题

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都只有一个（也就是只能放入背包一次）**



###### 完全背包问题

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**



###### 多重背包问题

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有s[i]个（也就是每个物品的数量不同）**



###### 分组背包问题

物品分为若干组，每一组中只能选一个



两种问题都是用dp解决，如果是二维的dp，即``dp[物品][重量]``，0-1及完全背包问题中遍历的顺序可以交换（先遍历物品还是遍历背包重量）；而如果是优化的一维dp（因为二维dp是从上到下、从左到右更新，可以用一维滚动的方式实现二维），0-1问题中必须先遍历物品再遍历重量，而且重量必须要逆序遍历（从最重到重量为0），否则会出现物品多次放入的情况，而完全背包问题中一维dp仍然可以随意交换遍历顺序，不过重量的遍历必须是正序（因为可以将物品多次放入背包）



完全背包问题中：如果求组合数，那么应该先遍历物品，再遍历重量（因为先遍历物品防止了物品的乱序放入）；如果求排列，应该先遍历重量，再遍历物品





状态f(i,j)是集合（如i，j条件下的各类选法的集合），其值是集合的某种属性（常见有max，min，数量），而状态转移方程即状态的计算方式，其实是集合的划分，将集合划分为比它小的子集合，再把这些子集和合并起来



* 0-1背包问题中集合的切分：必须选择i和不选择i物品

![01背包问题](.\图片\算法\01背包问题.png)

* 完全背包问题中集合的切分：选0-k件 i物品

![完全背包问题](.\图片\算法\完全背包问题.png)

初次优化（无需三次循环）

![完全背包问题优化1](.\图片\算法\完全背包问题优化1.png)

* 多重背包

多重背包问题和完全背包朴素算法几乎相同，只不过对于k新增了一个限制，要求不能超出本身的s[i]

![多重背包问题](.\图片\算法\多重背包问题.png)

但是优化的话，无法使用完全背包的优化方式

![多重背包问题优化](.\图片\算法\多重背包问题优化.png)针对每种物品s[i]，其实是枚举将0~s[i]件物品i放入集合，所以采取将s[i]拆分成若干组，每个组的数量为1,2,4,8,...,2^k,c，这些组的组合就可以组成0~s[i]件物品i的集合，只需要对每个组做0-1背包问题即可（即将一组物品当作一个)。



* 分组背包（每组选一个，若干个组）

`dp[i][j] // 只从前i组物品中选择，且总体积不会大于j的所有选法的max`

集合切分：第i组中选第几个物品



* 混合背包问题

每种物品有不同的背包类型，如第一种物品是0-1背包，第二种是完全背包，第三种是多重背包问题，那么只需要将多重背包先拆分成各个组变为0-1问题，然后遍历物品，遍历容量时根据不同的背包类型，更新`dp[j]`即可



##### 线性DP

状态计算时，递推有一些线性顺序（名字不重要）

[AcWing 898. 数字三角形 - AcWing](https://www.acwing.com/activity/content/problem/content/1002/)

##### 区间DP

[AcWing 282. 石子合并 - AcWing](https://www.acwing.com/activity/content/problem/content/1007/)

##### 数位统计类DP

一般其状态表示是一个区间的状态

[AcWing 338. 计数问题 - AcWing](https://www.acwing.com/activity/content/problem/content/1009/)

分情况讨论！

##### 状态压缩DP

[AcWing 291. 蒙德里安的梦想 - AcWing](https://www.acwing.com/activity/content/problem/content/1010/)

一个整数表示一个状态，即将这个整数看作是二进制数，每一位代表一个状态，以此实现压缩

##### 树形DP

[285. 没有上司的舞会 - AcWing题库](https://www.acwing.com/problem/content/287/)

```C++
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 6010;
int f[N][N];
// f[i][1]表示以i为根节点的树，参会人员中有i节点时的所有方案中的最大快乐度
// f[i][0]表示以i为根节点的树，参会人员中没有i节点时的所有方案中的最大快乐度

// 每个节点的快乐度
int happy[N];
// 使用邻接表存储树
int h[N], e[N], ne[N], idx;
bool has_father[N];

// a节点中增加子节点b
void add(int a, int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

// 从节点u开始遍历树
void dfs(int u)
{
    f[u][1] = happy[u];
    // 遍历儿子节点
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        dfs(j);
        
        // 方案中没有本节点u，所以儿子节点可以有也可以没有
        f[u][0] += max(f[j][0], f[j][1]);
        // 方案中有本节点u，为保证快乐max，儿子节点可能不能有
        f[u][1] += f[j][0];
    }
}

int main()
{
    int n;
    scanf("%d", &n);
    
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d", &happy[i]);
    }
    
    memset(h, -1, sizeof h);
    
    // 共有n-1条边，构成树
    for (int i = 0; i < n-1; ++i)
    {
        int a, b;
        scanf("%d %d", &a, &b);
        has_father[a] = true;
        add(b, a);
    }
    
    int root = 1;
    while (has_father[root])
    {
        root++;
    }
    
    // 遍历整棵树
    dfs(root);
    
    cout << max(f[root][0], f[root][1]);
    
}
```



类似题目似乎做过？

是的！！

[198. 打家劫舍 - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber/submissions/) 一维数组层次上的树形dp

不过此题也可以考虑为线性dp

##### 记忆化搜索

使用递归的方式求，而其他情况一般是迭代的方式；此类方式代码复杂度低

```C++
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 310;

int n, m;
int h[N][N];
int f[N][N];
// f[i][j] 表示从(i, j)开始滑的最大滑动距离


int dx[4] = {0, 0, -1, 1};
int dy[4] = {1, -1, 0, 0};

// 计算并返回f[x][y]的值
int dp(int x, int y)
{
    // 如果已经计算过就跳过
    if (f[x][y] != -1)
    {
        return f[x][y];
    }
    
    // 至少为1，即本点
    f[x][y] = 1;
    
    // 集合切分：从x y这一点出发，有四种滑动方式（上下左右），取最大的一种
    for (int i = 0; i < 4; ++i)
    {
        int a = x + dx[i];
        int b = y + dy[i];
        
        // 新的点不能越界，同时新的点一定要比原来的点低
        if (a >= 1 && a <= n && b >= 1 && b <= m && h[x][y] > h[a][b])
        {
            f[x][y] = max(f[x][y], dp(a, b) + 1);
            // 能使用这种递归方式计算出来的前提是 递归调用不会成环
        }
    }
    return f[x][y];
}

int main()
{
    scanf("%d %d", &n, &m);
    
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= m; ++j)
        {
            scanf("%d", &h[i][j]);
        }
    }
    
    memset(f, -1, sizeof f);
    
    int res = 0;
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= m; ++j)
        {
            res = max(res, dp(i, j));
        }
    }
    
    printf("%d", res);
    
    return 0;
}

```





##### DP求方案

要求拿出符合结果的那个方案，所以需要将状态转移记录下来，一般都是记录进入下一个状态的前一个状态是什么，然后逆序输出	  



PS：考虑集合的拆分时一般考虑最后一步怎么操作，如背包问题考虑最后一个物品放入的方式（放还是不放 ->0-1，放几个 -> 完全\多重，放组内的第几个 ->分组），最长上升子序列问题考虑倒数第二个元素放谁，最长公共子序列考虑a和b字符串的最后一个元素在不在子序列中等







#### DFS BFS

DFS没有模板，递归实现比较简单

BFS的一般套路为：

```C++
// 伪码
//1. queue 中设置初始状态
//2. while (!queue.empty())
{
    // 取出队头
    // 拓展队头的所有邻点
}

// 和二叉树的层序遍历一个路数，因为层序遍历就是BFS
```



PS：最短路问题是包含dp问题的，dp问题是没有环的最短路；而图的广度遍历中包含有最短路信息（边的权重为1），常用于解决最短路问题





矩阵中上下左右四个方向尝试时，采用类似向量方式：

```c++
// dx[i]和dy[i]组合在一起就是上下左右四个方向
// 即通过行列的微操作
int dx[4] = {-1, 1, 0, 0};
int dy[4] = {0, 0, -1, 1};

for (int i = 0; i < 4; ++i)
{
   x += dx[i];
   y += dy[i];
   // 检查新的x，y的有效性
   if (x >= 0 && x < n && y >= 0 && y < m)
   {
       ...
   }
}
```



有向无环图必有拓扑序列，所以有向无环图即拓扑图；BFS可用于输出拓扑序列，从入度为零的点开始，其实不一定使用BFS，随便某个集合用来存放入度为0的点就可以，只不过用BFS的队列比较习惯

#### 时间复杂度优化

[通过一道面试题目，讲一讲递归算法的时间复杂度！ | 代码随想录 (programmercarl.com)](https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html)


#### 愚蠢类错误

赋值和交换你居然有时候会混为一谈！！！！好好想想swap咋实现的。

map的操作需要也必须熟悉，首先要弄清楚map的各种返回类型，是key，还是value，而且map返回的value type其实是pair；map的遍历，索引也是老问题了！！



#### 针对sort自定义排序函数和priority_queue自定义排序函数的认识

首先，需要明确这是一个基础性问题，两者最大的区别在于sort是个函数模板，而priority_queue是类模板

直接看最常见的定义：

```C++
template< class RandomIt, class Compare >
void sort( RandomIt first, RandomIt last, Compare comp );

template<
    class T,
    class Container = std::vector<T>,//默认容器
    class Compare = std::less<typename Container::value_type>//默认排序规则，升序
> class priority_queue;
```

可以看出sort是函数，函数模板最大的特性就是类型参数T是由编译器根据传入的实参自行估计的（实参推断），而类模板中类型参数T也好，Container也好都需要显式声明，编译器无法自行推断

> c++17支持类模板参数推导？？？

所以在sort中利用lambda表达式指定排序函数时，一般做法为：

```C++
sort(vec_int.begin(), vec_int.end(), [](int a, int b){return a > b;});//改为降序
//其中第三参数的lambda表达式是个对象！！！不是类型，sort函数根据此实参推出了其类型Compare为decltype(xxx),xxx为这个lambda临时对象
```

而在声明一个自定义排序的priority_queue对象时，做法为：

```C++
priority_queue<int, vector<int>, [](int a, int b){return a > b;}> p;//error
//此式错误，因为创建的这个lambda表达式是个对象！！
//而根据类模板的显式声明要求，这里需要传入一个类型参数，即类型！！！不是对象。所以报错


auto cmp = [](int a, int b){return a > b;};
priority_queue<int, vector<int>, decltype(cmp)> p;//error
//此时根据decltype，可以得出cmp的类型！所以类模板知晓了Compare的类型，但是此时仍然错误
//因为priority_queue的默认构造函数不是一般ctor那样什么都不需要care！！
//看清楚官方提供的ctor
priority_queue() : priority_queue(Compare(), Container()) { }//本质上调用了另一个构造函数，即其中又调用了lambda这种特殊类和容器类的默认构造，
//但是lambda这种特殊类没有默认构造函数！
//所以上述式子仍然报错！



//一般使用的是
priority_queue<int, vector<int>, decltype(cmp)> p(cmp);
//对应于
explicit priority_queue(const Compare& compare)
    : priority_queue(compare, Container()) { }//其compare使用拷贝构造
```

lambda表达式可以构造出一个无名的函数对象（即所谓的ClosureType）

而Closure types are not DefaultConstructible，也就是没有默认构造函数，但是它有隐式声明的拷贝和移动构造函数



在调用priority_queue的构造函数问题上：

只有在类模板的类型参数使用lambda或函数指针这种没有默认构造的时候比较麻烦，还需要调用有参构造；

如果使用struct或者class，然后重载operator ()当作compare，是不需要这么麻烦，因为它们有默认构造

```C++
//使用函数指针
bool cmpfun(int a, int b)
{
  return a > b;
}

//还是需要借助function模板来说明排序函数的这个类，
priority_queue<int, vector<int>, function<bool(int, int)>> p(cmpfun);//function是有默认构造的，但还是需要传入函数指针作为参数，因为function的默认构造是创建一个空function，不是我们想要的，所以需要使用拷贝构造

priority_queue<int, vector<int>, decltype(cmpfun)> p(cmpfun);//错误使用；
//此处有一个误用，decltype一个函数时，它返回的是这个函数的返回类型，此例中对应于bool！而不是说明这个函数是什么类型！！
```

```c++
struct cmp
{
  bool operator()(int a, int b)
  {
    return a > b;
  }
};

priority_queue<int, vector<int>, cmp> p;//very clear
```

PS：priority_queue默认是大顶堆，且定义排序函数，a > b才会是小顶堆；和map或者sort时 a>b会是降序有点反。



#### delctype

* 如果`decltype`使用的表达式不是一个变量，则`decltype`返回表达式结果对应的类型。（简单理解为表达式的返回类型）；如果使用的是变量，那就返回变量的类型就可以
* 如果使用的是变量加一个括号，因变量是一个可以作为左值的特殊表达式，带上括号后，`decltype`将会返回引用类型！！其他情况下，只有这个变量本身是引用，才会返回引用类型
* `decltype`使用的是指针解引用，那么也会返回指针指向对象的引用类型

~~~C++
int a = 0;
int& b = a;//引用类型必须被初始化
int* p = &a;

decltype(a);//int
decltype((a));// int&
decltype(b);//int&
decltype(b+1);//int，把b这个引用类型作为表达式的一部分
decltype(*p);//int&

bool cmp(){return true;};


decltype(cmp);//bool
~~~



#### 容器适配器

queue、stack、priority_queue都是容器适配器，即利用其他容器做裁剪得到的。

STL默认实现中，以上三者中queue、stack采用deque双端队列作为底层；priority_queue采用vector作为底层容器；

而容器适配器构造函数，如果是默认构造，本质上会自动调用底层容器（和可能存在的Compare类）的默认构造；

如果要带参构造（除拷贝构造），必须从底层容器构造 ，如

`queue<TreeNode*> q {deque<TreeNode*> {root}};`

从底层容器deque开始构造 ，而**由于C++17支持类模板的参数推导，在可以推导成功的前提下，可以去除显式的模板参数**，所以可以进一步写为`queue {deque{root}};`根据`root`可以推得底层容器参数类型为`TreeNode*`，然后由此推得`queue`参数类型为`TreeNode*`



PS：C++11之后的骚操作越来越多了

`auto [val,left,right] = *root;`

可以从简单的类中按照声明顺序取出所有元素，root是`TreeNode*`，解引用得到`TreeNode`类型，然后顺序的取得其元素





#### 附录：

##### 一、常见C库函数：

```C++
#include <ctype.h>
//判断c是否为数字或字符，如果是返回非零，不是返回零
int isalnum(int c);
//查所传的字符是否是十进制数字字符
int isdigit(int c);
//判断是否为字母
int isalpha(int c);
//判断是否为空格
int isspace(int c);


//如果 c 有相对应的小写字母，则转为小写，否则不变，返回值为可被隐式转换为char的int型
int tolower(int c);
//转大写
int toupper(int c);



#include <string.h>
//返回needle字符串在haystack字符串中第一次出现的索引位置，如果needle为空，则返回0；找不到则返回-1
char *strstr(const char *haystack, const char *needle);


#include <stdlib.h>
//将输入的字符串转换为数字，如果传入的str不是数字的字符串，则返回0
//可使用有限状态机实现该函数
int atoi(const char *str)
```





##### 二、C++常见技巧

1）string 使用operator[pos]检索其中字符时，如果pos等于字符串的长度，那么将会返回null，而不会直接越界！！



2）swap的两种

```C++
void swap(int a, int b)
{
  int tmp = b;
  b = a;
  a = tmp;
}

//利用两个相同数异或为0，且0和任意数异或为数
void swap(int a, int b)
{
  a ^= b;
  b ^= a;
  a ^= b;
}
```



3）人类计算使用中缀表达式，例如：2+3 * 5；计算机从左到右扫描时，需要判断下一个运算数是多少，运算符优先级等问题，然后3*5，得到结果后再回到开头，重新加法，并不便利；所以计算机采用后缀表达式，上式可转变为2 3 5 * +，从左到右扫描，然后数字就压栈，遇到运算符就将栈顶俩个元素出栈计算，然后结果再压栈。

后缀表达式相当于二叉树的后序遍历，逆波兰表达式是后缀表达式的一种；

对于一个有效的逆波兰表达式，其长度$n$一定是奇数，且操作数的个数一定比运算符的个数多1个，即包含 $\frac{n+1}{2} $个操作数和 $\frac{n-1}{2} $个运算符



