贪心算法

局部最优从而求得全局最优

区间问题，按照区间开头或者结尾排序，有时候很重要；

想想问题之间转化，能不能转为同类型问题或者

数组需不需要提前处理下，统计一下信息：频率、第一次出现位置、最后一次出现位置、个数等



dp的本质是**穷举**所有状态，然后选择最优解；之后再做记忆数组之类的优化；

【选择】【状态】搞清楚



BFS题：

n叉树的层序遍历，

现在看来，不论是多叉树还是简单的二叉树，层序遍历就是BFS广度优先遍历算法，二者都利用队列来实现，以前居然没有关联起来过。

n叉树层序遍历这道题中，因为对输出结果的要求是每一层的节点区分开，所以除了BFS，重点就在于怎么区分某一层，在原有BFS的基础上内部再加一个外层的for循环，遍历完一层后，此时队列中刚好是下一层的节点。



删除有序数组的重复项，

不要总想着真正的删除元素，用不重复的元素将重复元素的位置覆盖即可；另外也说明了**有的时候排序是很好用的**，此题中有序后去重更易处理了

双指针：一个指针变动，另一个指针不动；或者说一个指针快，一个指针慢，快慢指针；数组类算法中常见



环



反转全部，反转部分



空间换时间，如果没办法就考虑这种，不要总想着原地完成，先写出一个解决方案再说！！





位运算需要汇总各类的，暂时遇到最多的是异或，





无论是dp还是其他算法，都会遇到自己创建一个一维或者二维数组，然后**赋予新的意义**，如`nums[i][j]`表示为第`i`行有没有`j`这个数字或者`j`表示某些状态，第`i`天在`j`这个状态下收益值





非常常见的位运算（paxos、文件操作权限等中也常见）：使用`|`表示赋予某值\权限，使用`&`检查是否拥有某值或某权限







辗转相除法  求最大公约数

```c++
int gcc(int a, int b)
{
  if (a < b)
  {
    swap(a,b);
  }
  
  while (b != 0)
  {
    int tmp = b;
    b = a%b;
    a = tmp;
  }
  return a;
}
```



整数求每个位的值（无论正、负）

```C++
while (x != 0)
{
  //个位数
  int t = x % 10;
  //把求所有位数都转为求个位数
  x /= 10;
}
```

**整数反转也好，字符串转整数也罢，转出来的值会不会超出int的取值范围很重要**！！`INT_MAX`，`INT_MIN`

>  [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)



回文三种做法：

1）双指针，一前一后

2）栈，先push进去，pop出来后是否相同

3）reverse后是否相同



链表中一次找到中间位置的做法：

两个指针，一个一次走一步，一个一次走两步；这样走的慢的指针就在中间位置（如果偶数，则为靠左的中间）

> 此法与之后提到的Floyd判圈算法思路相同



KMP算法：

模式串、前缀、后缀、partial match table、next数组

最后其实是next数组的构造！（这地方还是有疑问）





最长公共前缀：

一般想到的是所谓”横向扫描“，即每个字符串之间比较，前两个字符串比较后的前缀，再去和后面的字符串比较求前缀，最终的前缀即为公共最长前缀；这也符合以往编程直觉：即先for循环字符串数组，再对其中的每个字符串处理；但是这样只能两个两个字符串的比较，

所以转换下思维，直接每列之间比较，即先for循环某一个字符串，相当于找到了要比较的列字符，然后循环字符串数组；这样就相当于一次性所有的字符串之间同时比较某一个字符

题解中提到的分治法，和归并排序真的很像，分分分， 最后变成两两字符串比较

二分法，思路也很巧妙，根据结果的长度范围来不断缩小



二分查找中发现的问题：

二分查找时，求mid到底是相加除二还是右减左侧除二 + 左侧，还是有问题；另外left和right如果移动时的边界问题一直存在！！



链表类问题：

常见技巧为，**新增一个dummy节点，让它的next指向链表的头节点，用来当作虚拟头节点**，可以避免一大堆的删除头节点操作错误！！不用对头节点做特殊判断了（其实就是以前数据结构中学到的有头节点的链表）

> 「是否需要释放被删除节点对应的空间」这一问题，我们需要和面试官进行积极的沟通以达成一致
>
> 面试中沟通最重要，因为一个成熟的项目进行中，同事之间的沟通很重要，搞清楚各自在写什么，需求是什么，所以面试中会考察这方面；不要害怕问的问题太stupid，就不敢问！！

链表问题中，删除节点时常常需要其**前驱节点**

倒数第几个这种问题上，要么数学变换成正着数第几个，要么双指针，要么栈！（倒数问题上栈总是可以信任！）





「Floyd 判圈算法」（又称龟兔赛跑算法）

快慢两个指针，一个一次走两步，一个一次走一步，如果前方存在环，那么快指针将会首先进入环中，然后与慢指针在某个节点相遇（可能是套了几圈之后），如果没有环，那么快指针将会提前到达尾部nullptr





树 、 二叉树类题目：

树其实就是简化版的图，所以图的DFS、BFS都可对应的应用到树上

非递归写法：深度优先借助栈，广度优先借助队列；两者写起来其实几乎是一样的，只不过在图里面用DFS需要标记有没有访问过这个节点























#### 附录：

##### 一、常见C库函数：

```C++
#include <ctype.h>
//判断c是否为数字或字符，如果是返回非零，不是返回零
int isalnum(int c);
//查所传的字符是否是十进制数字字符
int isdigit(int c);
//判断是否为字母
int isalpha(int c);
//判断是否为空格
int isspace(int c);


//如果 c 有相对应的小写字母，则转为小写，否则不变，返回值为可被隐式转换为char的int型
int tolower(int c);
//转大写
int toupper(int c);



#include <string.h>
//返回needle字符串在haystack字符串中第一次出现的索引位置，如果needle为空，则返回0；找不到则返回-1
char *strstr(const char *haystack, const char *needle)
```





##### 二、C++常见技巧

1）string 使用operator[pos]检索其中字符时，如果pos等于字符串的长度，那么将会返回null，而不会直接越界！！