贪心算法

局部最优从而求得全局最优

区间问题，按照区间开头或者结尾排序，有时候很重要；

想想问题之间转化，能不能转为同类型问题或者

数组需不需要提前处理下，统计一下信息：频率、第一次出现位置、最后一次出现位置、个数等



dp的本质是**穷举**所有状态，然后选择最优解；之后再做记忆数组之类的优化；

【选择】【状态】搞清楚



BFS题：

n叉树的层序遍历，

现在看来，不论是多叉树还是简单的二叉树，层序遍历就是BFS广度优先遍历算法，二者都利用队列来实现，以前居然没有关联起来过。

n叉树层序遍历这道题中，因为对输出结果的要求是每一层的节点区分开，所以除了BFS，重点就在于怎么区分某一层，在原有BFS的基础上内部再加一个外层的for循环，遍历完一层后，此时队列中刚好是下一层的节点。



删除有序数组的重复项，

不要总想着真正的删除元素，用不重复的元素将重复元素的位置覆盖即可；另外也说明了**有的时候排序是很好用的**，此题中有序后去重更易处理了

双指针：一个指针变动，另一个指针不动；或者说一个指针快，一个指针慢，快慢指针；数组类算法中常见



环



反转全部，反转部分



空间换时间，如果没办法就考虑这种，不要总想着原地完成，先写出一个解决方案再说！！





位运算需要汇总各类的，暂时遇到最多的是异或，





无论是dp还是其他算法，都会遇到自己创建一个一维或者二维数组，然后**赋予新的意义**，如`nums[i][j]`表示为第`i`行有没有`j`这个数字或者`j`表示某些状态，第`i`天在`j`这个状态下收益值





非常常见的位运算（paxos、文件操作权限等中也常见）：使用`|`表示赋予某值\权限，使用`&`检查是否拥有某值或某权限







辗转相除法  求最大公约数

```c++
int gcc(int a, int b)
{
  if (a < b)
  {
    swap(a,b);
  }
  
  while (b != 0)
  {
    int tmp = b;
    b = a%b;
    a = tmp;
  }
  return a;
}
```



整数求每个位的值（无论正、负）

```C++
while (x != 0)
{
  //个位数
  int t = x % 10;
  //把求所有位数都转为求个位数
  x /= 10;
}
```

**整数反转也好，字符串转整数也罢，转出来的值会不会超出int的取值范围很重要**！！`INT_MAX`，`INT_MIN`

>  [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)



回文三种做法：

1）双指针，一前一后

2）栈，先push进去，pop出来后是否相同

3）reverse后是否相同



链表中一次找到中间位置的做法：

两个指针，一个一次走一步，一个一次走两步；这样走的慢的指针就在中间位置（如果偶数，则为靠左的中间）

> 此法与之后提到的Floyd判圈算法思路相同



KMP算法：

模式串、前缀、后缀、partial match table、next数组

最后其实是next数组的构造！（这地方还是有疑问）





最长公共前缀：

一般想到的是所谓”横向扫描“，即每个字符串之间比较，前两个字符串比较后的前缀，再去和后面的字符串比较求前缀，最终的前缀即为公共最长前缀；这也符合以往编程直觉：即先for循环字符串数组，再对其中的每个字符串处理；但是这样只能两个两个字符串的比较，

所以转换下思维，直接每列之间比较，即先for循环某一个字符串，相当于找到了要比较的列字符，然后循环字符串数组；这样就相当于一次性所有的字符串之间同时比较某一个字符

题解中提到的分治法，和归并排序真的很像，分分分， 最后变成两两字符串比较

二分法，思路也很巧妙，根据结果的长度范围来不断缩小



二分查找中发现的问题：

二分查找时，求mid到底是相加除二还是右减左侧除二 + 左侧，还是有问题；另外left和right如果移动时的边界问题一直存在！！

利用ACWing模板，可以简单的完成二分法，但是也发现在写浮点数二分法的check函数的时候，等于号的情况必须被谨慎考虑，如`if (nums[mid] <= target)`，还是只写`nums[mid] < target`，把等于号情况扔给else处理，这两种写法在最后`return left` 和 `return right`是不同的，因为浮点数二分跳出while循环的条件并不是left和right相等，浮点数运算下两者不能保证完全相等！！







链表类问题：

常见技巧为，**新增一个dummy节点，让它的next指向链表的头节点，用来当作虚拟头节点**，可以避免一大堆的删除头节点操作错误！！不用对头节点做特殊判断了（其实就是以前数据结构中学到的有头节点的链表）

> 「是否需要释放被删除节点对应的空间」这一问题，我们需要和面试官进行积极的沟通以达成一致
>
> 面试中沟通最重要，因为一个成熟的项目进行中，同事之间的沟通很重要，搞清楚各自在写什么，需求是什么，所以面试中会考察这方面；不要害怕问的问题太stupid，就不敢问！！

链表问题中，删除节点、插入节点时常常需要其**前驱节点**，新增dummy也方便找前驱prev

倒数第几个这种问题上，要么数学变换成正着数第几个，要么双指针，要么栈！（倒数问题上栈总是可以信任！）





「Floyd 判圈算法」（又称龟兔赛跑算法）

快慢两个指针，一个一次走两步，一个一次走一步，如果前方存在环，那么快指针将会首先进入环中，然后与慢指针在某个节点相遇（可能是套了几圈之后），如果没有环，那么快指针将会提前到达尾部nullptr





树 、 二叉树类题目：

树其实就是简化版的图，所以图的DFS、BFS都可对应的应用到树上

非递归写法：深度优先借助栈，广度优先借助队列；两者写起来其实几乎是一样的，只不过在图里面用DFS需要标记有没有访问过这个节点





BST树的各节点不能有相等的，要遵循严格大于或小于





动态规划类题目：

搞清楚设定的dp数组的元素含义



###### 哈希表类：

首先，老生常谈：C++中的hash表分两类实现，一种是红黑树实现的set（+multiset）、map（+multimap），特点是会按照key排序，是有序的，因为红黑树本质就是平衡的二叉搜索树，查询效率和增删效率均为O(lgn)；

另一类是后来加入std的，unordered_set、unordered_map，底层使用hash table实现，查询效率和增删效率均为O(1)，特点是无序的，这类更像是以往常规想法中的哈希。

这两类共同的特点就是插入后，key值不能更改，只能删除再插入



空间换时间策略的大师

查询元素第一次出现的位置时，常常使用hash





###### 位运算类：

求某个无符号数n的二进制写法中1的个数，用`1 << i`来让1不断提升，然后与n做与运算，则只有当n的这一位也是1时，与运算为true



| name   | function       | usage                                  |
| ------ | -------------- | -------------------------------------- |
| 异或 ^   | 相同为0，不同为1      | 两个数相等，则异或结果为0，0和数b异或结果为b<br />且异或遵守交换律 |
| 逻辑与 &  | 都是1为1，其余为0     |                                        |
| 逻辑或 \| | 只要有一个1即为1，其余为0 |                                        |
|        |                |                                        |
|        |                |                                        |

`__builtin_popcount`：内置函数求二进制中1的个数



Brian Kernighan算法：`n`与`n-1`做逻辑与运算，会把n的最低位的1置为0，所以逻辑与的结果和结果-1，继续做逻辑与运算，运算的次数即为1的个数



* 求n的第k位：首先，将n的第k位移到个位，接着和1做逻辑与；`n >> k & 1`

* lowbit(x)：返回x的最后一位1（x二进制从左往右的最后一个1及余下的0组成的数）；如1010000，lowbit后为10000

  应用：求x中1的个数，x -= lowbit(x)，减到0为止所用次数即为1个数

  lowbit实际为 `x & (-x)`即 `x & (~x + 1)`

###### 离散化

离散化适用情况是：在一个很大范围的数内，有效的（或需要拿出使用的）数的数量较少，如果直接对整个数做操作，如前缀和等，占用空间过大，耗时较久，所以将其中有效的部分提取出来，离散化为另一个值（如映射为数组索引，有些类似hash映射，模板中用二分查找作为离散函数），然后对离散化后的值做操作

题目：区间和



###### 区间合并

预处理基本是排序，按照区间的左端点排序或者右端点排序或者做右端点双关键字排序







质数问题：（感觉考的概率很小，记录下）

暴力查找是O(n^2)，很慢

改进版的暴力查找，如：查找y是否为质数，x是其中一个因数，则y/x必然也是一个因数，而在x和y/x中选择一个较小的，范围必然在[2, sqrt(y)]，所以检索y的开方即可

埃氏筛：如果x是质数，那么2x，3x...肯定不是质数，根据此规律可求质数；而实际上不需要从2x开始判定不是质数，从`x*x`开始即可，因为 2x,3x,… 这些数一定在 `x*x` 之前就被其他数的倍数标记过了，为防止重复标记“不是质数”，直接从`x*x`即可

线性筛：埃氏筛在标记合数时仍然存在冗余，如45会被3和5都标记，所以引入线性筛，标记不在仅当x是质数时，而是针对所有整数，同时维持一个质数集合primes，每个整数与质数集合中的质数的乘积均标记为合数，同时为防止重复标记，当当前的整数i与某个质数primes[j]求余为0时停止标记（i可被primes[j]整除）。因为下一个即将被标记的数`i*primes[j+1]`必然在之后的某个i时被标记！因为`i*primes[j+1]；会在之后的整数等于i/primes[j] * primes[j+1]的时候被标记，而且是在乘以primes[j]时就标记`，从而防止了重复标记



###### 数组类

1、数组题目中双指针总是很值得尝试的方法

> 第一次会，第二次不会了！！需加强
>  [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)
>
>  [27. 移除元素](https://leetcode.cn/problems/remove-element/)

若为两个同向指针，通过某些条件，让其中一个指针走慢（满足条件才会++），所以关键在于找出那个条件来；

当然也有对向的双指针，还有位于不同序列的指针，如归并排序

滑动窗口也属于双指针，不过区别在于滑动窗口的起点也会随情况调整

2、二分查找的各种用法（二分要求有序，且可随机访问，所以属于数组类）

3、有时先排序也不失为好法子







###### 愚蠢类错误

赋值和交换你居然有时候会混为一谈！！！！好好想想swap咋实现的。







#### 附录：

##### 一、常见C库函数：

```C++
#include <ctype.h>
//判断c是否为数字或字符，如果是返回非零，不是返回零
int isalnum(int c);
//查所传的字符是否是十进制数字字符
int isdigit(int c);
//判断是否为字母
int isalpha(int c);
//判断是否为空格
int isspace(int c);


//如果 c 有相对应的小写字母，则转为小写，否则不变，返回值为可被隐式转换为char的int型
int tolower(int c);
//转大写
int toupper(int c);



#include <string.h>
//返回needle字符串在haystack字符串中第一次出现的索引位置，如果needle为空，则返回0；找不到则返回-1
char *strstr(const char *haystack, const char *needle)
```





##### 二、C++常见技巧

1）string 使用operator[pos]检索其中字符时，如果pos等于字符串的长度，那么将会返回null，而不会直接越界！！