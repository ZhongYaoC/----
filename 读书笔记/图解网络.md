### 浏览器中输入网址后会发生什么

网络如何工作的总体性描述。

#### 以往的误区

1、ARP通过广播形式寻找MAC地址时，广播报中的IP是通过路由表查找后对应项目的`Gateway`列，不是最终的目的IP，因为报文可能会经过多个路由器，跨越多个网络才能够到达最终目的地。

2、由1可知，在报文传输过程中，MAC头是不断变化的。

3、交换机本身没有MAC地址，路由器有自己的MAC地址和IP地址；交换机只负责转发，所以不会检查收到的报文的MAC地址是不是本机（想检查自己也没有），路由器和网卡会检查收到的报文的目的MAC是不是自己，如果不是直接丢弃

4、

MSS：TCP协议时的数据段（应用层报文）的最大长度（即仅抛去TCP头部后的部分）

MTU：数据链路层中数据段（即整个IP报）的最大长度（即仅抛去MAC头部后的部分）

不同阶段对于数据段的定义不同



### Linux 系统是如何收发网络包的

Linux系统中的网络协议仅为

应用层、传输层、网络层、网络接口层（数据链路+物理层）

#### 网络包接收

网卡接收到网络报文之后，会通过DMA放入到内存中，此部分区域为一个Ring Buffer；然后触发硬件中断通知CPU有新的网络包到达；如果每一个网络报文都触发一个中断，CPU效率将会下降，所以一般采用中断和轮询相结合的方式，如触发一个中断后，使用`poll`检查所有套接字描述符是否就绪。

**硬件中断**主要负责**暂时屏蔽中断**，即网路包直接放入内存不再触发中断，然后触发**软中断**，结束后**解除**之前屏蔽的中断。

而Linux内核中的 `ksoftirqd` 线程专门负责软中断的处理，当 `ksoftirqd` 内核线程收到软中断后，就会来轮询处理数据。`ksoftirqd` 线程会从 Ring Buffer 中获取一个数据帧，用 `sk_buff` 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。（此时才交由网络协议栈处理）

网络协议栈中层层检查报文，拆除对应包头并交由上层协议处理；传输层中得到数据并放入socket的内核接收缓冲区，最后，应用程序通过系统调用，将内核缓冲区的数据拷贝到用户态的缓冲区。（每个socket都有对应的内核接收缓冲区）



#### 网络包发送

网络包发送和接收是相反的步骤，首先应用层通过系统调用（`send()`）进入内核态，内核会将发送的数据拷贝到内核态的`sk_buff` 内存，并将其加入到发送缓冲区（此处存疑？？unp书中说没有实际的发送缓冲区）。

紧接着，网络协议栈Socket 发送缓冲区中取出 `sk_buff`，并按照 TCP/IP 协议栈从上到下逐层处理；

如果是TCP传输，那么会先拷贝一个新的`sk_buff`副本（此处的副本仅包含为TCP部分），因为TCP协议保证可靠传输，可以超时重传，在接收到对应的ack报文之后才删除此副本，释放内存。

如果IP层中的数据超出MTU，则分片处理为多个数据包。

在完成协议栈的填充之后，会将网络包放置到网卡的发送队列，会触发一个**软中断**告知网卡驱动程序，有新的网络包需要发送，网卡驱动程序会从发送队列中读取`sk_buff`，并将此`sk_buff`复制到Ring Buffer中，接着将`sk_buff`数据映射到网卡可以访问的内存DMA区域，最终触发发送。

当数据发送完成以后，其实工作并没有结束，因为内存还没有清理。当发送完成的时候，网卡设备会触发一个**硬中断**来释放内存，主要是释放 `sk_buff` 内存和清理 Ring Buffer 内存。

最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的 `sk_buff` 。

>  `sk_buff`在此处指代各协议层的整个包，是变化的。
>
> 每一层的数据如果采用不同的数据结构，将会在协议层之间不断复制，降低效率，所以采用相同的数据结构，提前分配一块足够的空间，在不同层次时，移动指针位置指向对应的报文头即可。

##### 发送网络数据的时候，涉及几次内存拷贝操作？

1、调用发送数据的系统调用时，内核会申请内核态的`sk_buff`，将需要发送的数据从用户态拷贝到内核态

2、使用TCP协议传输时，当由传输层进入网络层时，会拷贝一份`sk_buff`的副本，副本送往网络层，等发送之后就会释放，但是原始的`sk_buff`会一直保存，直到收到对应报文的ACK才会释放

3、当IP层发现整个报文（`sk_buff`）大小超出MTU，会额外申请`sk_buff`，并将原本的`sk_buff`拷贝为多个小的`sk_buff`



### HTTP篇

