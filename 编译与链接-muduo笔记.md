C语言编译模型成因：

早期计算机内存资源很小，编译器没办法在内存中表示单个源文件的抽象语法树，更不可能把整个程序（多个源文件）放入内存，已完成相互调用（不同源文件的函数相互调用、外部变量等）。所以编译器只能分别编译多个源文件，生成多个目标文件，再设法把目标文件组合成（链接）一个可执行文件。

为在匮乏的内存资源中尽量实现分离编译，C语言采用隐式函数声明，即使用前文未定义的函数时（如调用printf函数，但未include），编译器不会报错，因为编译器不会去检查函数原型，不检查参数个数，类型，返回值类型等，从而实现了分离编译，然后链接成为一个大的执行文件；但这就依赖于链接时不能出错，并且自身需要明确的知道所需信息；所以出现了头文件和预编译，通过将需要使用的公共信息做成头文件，放到/usr/include，然后程序包含头文件即可，而预编译就是将头文件在编译之前直接展开在代码中。



同样由于内存限制，C语言使用“单遍编译 one pass”，即从头到尾扫描源码，边扫描边生成对应目标代码，无法知晓后面的代码，同时看过即忘。所以：

1）使用结构体，需要先定义，才能访问其成员；否则无法知晓结构体中各成员的类型及偏移量，无法立刻生成目标代码；

2）同样局部变量也需要先定义再使用，否则编译器看到局部变量无法知晓其类型和stack中的偏移量；

3）而外部变量（函数外部的全局变量），编译器只需要其类型及名称，不需要知晓地址，因此需要先声明再使用；目标代码中外部变量处是空白，留给链接器填充具体地址；

4）基于隐式函数声明，函数调用时，编译器可以马上生成调用函数的汇编代码（参数入栈、获取返回值等），但真实的函数位置需要链接器填充。



C++编译模型：

1、为与C语言兼容，C++继承了单遍编译one pass（只是装作好像是单遍编译，因为新增了语言特性）

因为编译器只能根据目前看到的代码做出决策，所以读之后的代码不会影响前面做出的决策，从而影响了C++的名字查找（name lookup）和函数重载决议；

C++只能通过解析源代码获知名字的含义，故编译器的符号表中要保存目前看到的每个名字的含义，如class的成员定义、已声明的变量、已知的函数原型等；

函数重载决议：调用一个函数时，只能从已经看到的该函数的同名函数中选择最匹配的，即使后面又更适合的匹配也不影响当前决定；（但class成员函数例外，编译器会先扫描一遍class定义，再处理成员函数，所以成员函数决议时是选择全局最优匹配）



2、前向声明 forward declaration 以减少编译期依赖

1）函数前向声明

当调用某函数时，编译器pares此处调用时，需要生成函数调用的目标文件，需要知晓函数的参数类型、个数和返回值类型，所以需要在调用前知晓该函数的声明（还是因为单遍编译）；但不需要函数实现，所以编译期间不会报错，但如果一直没有函数定义，链接器会报错。

C++区分声明和定义，但区分声明和定义导致可能存在声明和定义之间存在偏差，如声明的函数仅一个参数，定义的函数两个参数（这种属于链接器可以发现的）；但是它无法发现声明和定义的函数中返回值类型和参数顺序区分，如声明函数void fun(int height, int width)，定义中为void fun(int width, int height)，不会有报错，但计算结果可能就是错误的。

如果一个程序比较简单（没有函数互相调用），可以把基础函数实现写在前面，这样可以避免前向声明函数原型

2）class前向声明

有时class的前向声明是必需的，如类之间互指；有时class的完整定义是必需的，如访问class的成员，或者要知道class的大小以便分配空间。

![前向声明](C:\Users\zhong\Pictures\前向声明.png)

合理的class前向声明可以减少include（因为在不需要看到完整定义的场景里，如图所示，只要没有直接的调用，那就不需要include 类的定义）





链接 linking

one-pass linker（C语言链接模型）：

只扫描一遍，基础的目标文件放在后面；扫描时，记录需要调用其他目标文件的位置及所需文件（即空白or未查到定义的符号），当扫描遇到空白所需符号时，回翻至空白处填入，然后再回来继续扫描；

之所以基础目标文件在后面，是因为占用内存小；如果先扫描基础文件，因为不知道具体哪些符号会被调用，所以需要记录所有可能被调用的符号，内存消耗和所有库大小之和成正比；而后扫描基础文件，只需要记录空白（尚未查到定义的符号）就可以。